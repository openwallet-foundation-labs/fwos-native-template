import type { BaseRecord } from './BaseRecord';
import type { BaseRecordConstructor, Query, StorageService } from './StorageService';
import type { AgentContext } from '../agent';
import { AgentDependencies } from '../agent/AgentDependencies';
export declare class IndyStorageService<T extends BaseRecord<any, any, any>> implements StorageService<T> {
    private indy;
    private static DEFAULT_QUERY_OPTIONS;
    constructor(agentDependencies: AgentDependencies);
    private transformToRecordTagValues;
    private transformFromRecordTagValues;
    /**
     * Transforms the search query into a wallet query compatible with indy WQL.
     *
     * The format used by AFJ is almost the same as the indy query, with the exception of
     * the encoding of values, however this is handled by the {@link IndyStorageService.transformToRecordTagValues}
     * method.
     */
    private indyQueryFromSearchQuery;
    private recordToInstance;
    /** @inheritDoc */
    save(agentContext: AgentContext, record: T): Promise<void>;
    /** @inheritDoc */
    update(agentContext: AgentContext, record: T): Promise<void>;
    /** @inheritDoc */
    delete(agentContext: AgentContext, record: T): Promise<void>;
    /** @inheritDoc */
    deleteById(agentContext: AgentContext, recordClass: BaseRecordConstructor<T>, id: string): Promise<void>;
    /** @inheritDoc */
    getById(agentContext: AgentContext, recordClass: BaseRecordConstructor<T>, id: string): Promise<T>;
    /** @inheritDoc */
    getAll(agentContext: AgentContext, recordClass: BaseRecordConstructor<T>): Promise<T[]>;
    /** @inheritDoc */
    findByQuery(agentContext: AgentContext, recordClass: BaseRecordConstructor<T>, query: Query<T>): Promise<T[]>;
    private search;
}
