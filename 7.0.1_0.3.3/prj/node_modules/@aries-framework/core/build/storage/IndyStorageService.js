"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var IndyStorageService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyStorageService = void 0;
const constants_1 = require("../constants");
const error_1 = require("../error");
const plugins_1 = require("../plugins");
const JsonTransformer_1 = require("../utils/JsonTransformer");
const indyError_1 = require("../utils/indyError");
const type_1 = require("../utils/type");
const assertIndyWallet_1 = require("../wallet/util/assertIndyWallet");
let IndyStorageService = IndyStorageService_1 = class IndyStorageService {
    constructor(agentDependencies) {
        this.indy = agentDependencies.indy;
    }
    transformToRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
            // If the value is a boolean string ('1' or '0')
            // use the boolean val
            if (value === '1' && (key === null || key === void 0 ? void 0 : key.includes(':'))) {
                const [tagName, tagValue] = key.split(':');
                const transformedValue = transformedTags[tagName];
                if (Array.isArray(transformedValue)) {
                    transformedTags[tagName] = [...transformedValue, tagValue];
                }
                else {
                    transformedTags[tagName] = [tagValue];
                }
            }
            // Transform '1' and '0' to boolean
            else if (value === '1' || value === '0') {
                transformedTags[key] = value === '1';
            }
            // If 1 or 0 is prefixed with 'n__' we need to remove it. This is to prevent
            // casting the value to a boolean
            else if (value === 'n__1' || value === 'n__0') {
                transformedTags[key] = value === 'n__1' ? '1' : '0';
            }
            // Otherwise just use the value
            else {
                transformedTags[key] = value;
            }
        }
        return transformedTags;
    }
    transformFromRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
            // If the value is of type null we use the value undefined
            // Indy doesn't support null as a value
            if (value === null) {
                transformedTags[key] = undefined;
            }
            // If the value is a boolean use the indy
            // '1' or '0' syntax
            else if ((0, type_1.isBoolean)(value)) {
                transformedTags[key] = value ? '1' : '0';
            }
            // If the value is 1 or 0, we need to add something to the value, otherwise
            // the next time we deserialize the tag values it will be converted to boolean
            else if (value === '1' || value === '0') {
                transformedTags[key] = `n__${value}`;
            }
            // If the value is an array we create a tag for each array
            // item ("tagName:arrayItem" = "1")
            else if (Array.isArray(value)) {
                value.forEach((item) => {
                    const tagName = `${key}:${item}`;
                    transformedTags[tagName] = '1';
                });
            }
            // Otherwise just use the value
            else {
                transformedTags[key] = value;
            }
        }
        return transformedTags;
    }
    /**
     * Transforms the search query into a wallet query compatible with indy WQL.
     *
     * The format used by AFJ is almost the same as the indy query, with the exception of
     * the encoding of values, however this is handled by the {@link IndyStorageService.transformToRecordTagValues}
     * method.
     */
    indyQueryFromSearchQuery(query) {
        // eslint-disable-next-line prefer-const
        let { $and, $or, $not } = query, tags = __rest(query, ["$and", "$or", "$not"]);
        $and = $and === null || $and === void 0 ? void 0 : $and.map((q) => this.indyQueryFromSearchQuery(q));
        $or = $or === null || $or === void 0 ? void 0 : $or.map((q) => this.indyQueryFromSearchQuery(q));
        $not = $not ? this.indyQueryFromSearchQuery($not) : undefined;
        const indyQuery = Object.assign(Object.assign({}, this.transformFromRecordTagValues(tags)), { $and,
            $or,
            $not });
        return indyQuery;
    }
    recordToInstance(record, recordClass) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const instance = JsonTransformer_1.JsonTransformer.deserialize(record.value, recordClass);
        instance.id = record.id;
        const tags = record.tags ? this.transformToRecordTagValues(record.tags) : {};
        instance.replaceTags(tags);
        return instance;
    }
    /** @inheritDoc */
    async save(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
            await this.indy.addWalletRecord(agentContext.wallet.handle, record.type, record.id, value, tags);
        }
        catch (error) {
            // Record already exists
            if ((0, indyError_1.isIndyError)(error, 'WalletItemAlreadyExists')) {
                throw new error_1.RecordDuplicateError(`Record with id ${record.id} already exists`, { recordType: record.type });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async update(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
            await this.indy.updateWalletRecordValue(agentContext.wallet.handle, record.type, record.id, value);
            await this.indy.updateWalletRecordTags(agentContext.wallet.handle, record.type, record.id, tags);
        }
        catch (error) {
            // Record does not exist
            if ((0, indyError_1.isIndyError)(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
                    recordType: record.type,
                    cause: error,
                });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async delete(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            await this.indy.deleteWalletRecord(agentContext.wallet.handle, record.type, record.id);
        }
        catch (error) {
            // Record does not exist
            if ((0, indyError_1.isIndyError)(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
                    recordType: record.type,
                    cause: error,
                });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async deleteById(agentContext, recordClass, id) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            await this.indy.deleteWalletRecord(agentContext.wallet.handle, recordClass.type, id);
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${id} not found.`, {
                    recordType: recordClass.type,
                    cause: error,
                });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async getById(agentContext, recordClass, id) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            const record = await this.indy.getWalletRecord(agentContext.wallet.handle, recordClass.type, id, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
            return this.recordToInstance(record, recordClass);
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${id} not found.`, {
                    recordType: recordClass.type,
                    cause: error,
                });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async getAll(agentContext, recordClass) {
        var _a, e_1, _b, _c;
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const recordIterator = this.search(agentContext.wallet, recordClass.type, {}, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
            for (var _d = true, recordIterator_1 = __asyncValues(recordIterator), recordIterator_1_1; recordIterator_1_1 = await recordIterator_1.next(), _a = recordIterator_1_1.done, !_a;) {
                _c = recordIterator_1_1.value;
                _d = false;
                try {
                    const record = _c;
                    records.push(this.recordToInstance(record, recordClass));
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = recordIterator_1.return)) await _b.call(recordIterator_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return records;
    }
    /** @inheritDoc */
    async findByQuery(agentContext, recordClass, query) {
        var _a, e_2, _b, _c;
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const indyQuery = this.indyQueryFromSearchQuery(query);
        const recordIterator = this.search(agentContext.wallet, recordClass.type, indyQuery, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
            for (var _d = true, recordIterator_2 = __asyncValues(recordIterator), recordIterator_2_1; recordIterator_2_1 = await recordIterator_2.next(), _a = recordIterator_2_1.done, !_a;) {
                _c = recordIterator_2_1.value;
                _d = false;
                try {
                    const record = _c;
                    records.push(this.recordToInstance(record, recordClass));
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = recordIterator_2.return)) await _b.call(recordIterator_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return records;
    }
    search(wallet, type, query, _a) {
        var { limit = Infinity } = _a, options = __rest(_a, ["limit"]);
        return __asyncGenerator(this, arguments, function* search_1() {
            try {
                const searchHandle = yield __await(this.indy.openWalletSearch(wallet.handle, type, query, options));
                let records = [];
                // Allow max of 256 per fetch operation
                const chunk = limit ? Math.min(256, limit) : 256;
                // Loop while limit not reached (or no limit specified)
                while (!limit || records.length < limit) {
                    // Retrieve records
                    const recordsJson = yield __await(this.indy.fetchWalletSearchNextRecords(wallet.handle, searchHandle, chunk));
                    if (recordsJson.records) {
                        records = [...records, ...recordsJson.records];
                        for (const record of recordsJson.records) {
                            yield yield __await(record);
                        }
                    }
                    // If the number of records returned is less than chunk
                    // It means we reached the end of the iterator (no more records)
                    if (!records.length || !recordsJson.records || recordsJson.records.length < chunk) {
                        yield __await(this.indy.closeWalletSearch(searchHandle));
                        return yield __await(void 0);
                    }
                }
            }
            catch (error) {
                throw new error_1.IndySdkError(error, `Searching '${type}' records for query '${JSON.stringify(query)}' failed`);
            }
        });
    }
};
IndyStorageService.DEFAULT_QUERY_OPTIONS = {
    retrieveType: true,
    retrieveTags: true,
};
IndyStorageService = IndyStorageService_1 = __decorate([
    (0, plugins_1.injectable)()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ,
    __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
    __metadata("design:paramtypes", [Object])
], IndyStorageService);
exports.IndyStorageService = IndyStorageService;
//# sourceMappingURL=IndyStorageService.js.map