"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkProofRequestForDuplicates = void 0;
const AriesFrameworkError_1 = require("../error/AriesFrameworkError");
function attributeNamesToArray(proofRequest) {
    // Attributes can contain either a `name` string value or an `names` string array. We reduce it to a single array
    // containing all attribute names from the requested attributes.
    return Array.from(proofRequest.requestedAttributes.values()).reduce((names, a) => [...names, ...(a.name ? [a.name] : a.names ? a.names : [])], []);
}
function predicateNamesToArray(proofRequest) {
    return Array.from(new Set(Array.from(proofRequest.requestedPredicates.values()).map((a) => a.name)));
}
function assertNoDuplicates(predicates, attributeNames) {
    const duplicates = predicates.filter((item) => attributeNames.indexOf(item) !== -1);
    if (duplicates.length > 0) {
        throw new AriesFrameworkError_1.AriesFrameworkError(`The proof request contains duplicate predicates and attributes: ${duplicates.toString()}`);
    }
}
// TODO: This is still not ideal. The requested groups can specify different credentials using restrictions.
function checkProofRequestForDuplicates(proofRequest) {
    const attributes = attributeNamesToArray(proofRequest);
    const predicates = predicateNamesToArray(proofRequest);
    assertNoDuplicates(predicates, attributes);
}
exports.checkProofRequestForDuplicates = checkProofRequestForDuplicates;
//# sourceMappingURL=indyProofRequest.js.map