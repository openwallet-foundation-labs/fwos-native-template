"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsStringOrStringArray = exports.IsMap = exports.DateParser = exports.DateTransformer = exports.MetadataTransformer = exports.RecordTransformer = void 0;
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const luxon_1 = require("luxon");
const Metadata_1 = require("../storage/Metadata");
const JsonTransformer_1 = require("./JsonTransformer");
/**
 * Decorator that transforms json to and from corresponding record.
 *
 * @example
 * class Example {
 *   RecordTransformer(Service)
 *   private services: Record<string, Service>;
 * }
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function RecordTransformer(Class) {
    return (0, class_transformer_1.Transform)(({ value, type }) => {
        switch (type) {
            case class_transformer_1.TransformationType.CLASS_TO_PLAIN:
                return Object.entries(value).reduce((accumulator, [key, attribute]) => (Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.toJSON(attribute) })), {});
            case class_transformer_1.TransformationType.PLAIN_TO_CLASS:
                return Object.entries(value).reduce((accumulator, [key, attribute]) => (Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.fromJSON(attribute, Class) })), {});
            default:
                return value;
        }
    });
}
exports.RecordTransformer = RecordTransformer;
/*
 * Decorator that transforms to and from a metadata instance.
 */
function MetadataTransformer() {
    return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
            return Object.assign({}, value.data);
        }
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
            return new Metadata_1.Metadata(value);
        }
        if (type === class_transformer_1.TransformationType.CLASS_TO_CLASS) {
            return new Metadata_1.Metadata(Object.assign({}, value.data));
        }
    });
}
exports.MetadataTransformer = MetadataTransformer;
/**
 * Decorator that transforms to and from a date instance.
 */
function DateTransformer() {
    return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
            return value.toISOString();
        }
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
            return new Date(value);
        }
        if (type === class_transformer_1.TransformationType.CLASS_TO_CLASS) {
            return new Date(value.getTime());
        }
    });
}
exports.DateTransformer = DateTransformer;
/*
 * Function that parses date from multiple formats
 * including SQL formats.
 */
function DateParser(value) {
    const parsedDate = new Date(value);
    if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
        return parsedDate;
    }
    const luxonDate = luxon_1.DateTime.fromSQL(value);
    if (luxonDate.isValid) {
        return new Date(luxonDate.toString());
    }
    return new Date();
}
exports.DateParser = DateParser;
/**
 * Checks if a given value is a Map
 */
function IsMap(validationOptions) {
    return (0, class_validator_1.ValidateBy)({
        name: 'isMap',
        validator: {
            validate: (value) => value instanceof Map,
            defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + '$property must be a Map', validationOptions),
        },
    }, validationOptions);
}
exports.IsMap = IsMap;
/**
 * Checks if a given value is a string or string array.
 */
function IsStringOrStringArray(validationOptions) {
    return (0, class_validator_1.ValidateBy)({
        name: 'isStringOrStringArray',
        validator: {
            validate: (value) => (0, class_validator_1.isString)(value) || (Array.isArray(value) && value.every((v) => (0, class_validator_1.isString)(v))),
            defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + '$property must be a string or string array', validationOptions),
        },
    }, validationOptions);
}
exports.IsStringOrStringArray = IsStringOrStringArray;
//# sourceMappingURL=transformers.js.map