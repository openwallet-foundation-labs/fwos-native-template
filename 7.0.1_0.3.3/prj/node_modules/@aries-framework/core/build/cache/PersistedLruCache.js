"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistedLruCache = void 0;
const lru_map_1 = require("lru_map");
const CacheRecord_1 = require("./CacheRecord");
class PersistedLruCache {
    constructor(cacheId, limit, cacheRepository) {
        this.cacheId = cacheId;
        this.limit = limit;
        this.cacheRepository = cacheRepository;
    }
    async get(agentContext, key) {
        const cache = await this.getCache(agentContext);
        return cache.get(key);
    }
    async set(agentContext, key, value) {
        const cache = await this.getCache(agentContext);
        cache.set(key, value);
        await this.persistCache(agentContext);
    }
    async getCache(agentContext) {
        if (!this._cache) {
            const cacheRecord = await this.fetchCacheRecord(agentContext);
            this._cache = this.lruFromRecord(cacheRecord);
        }
        return this._cache;
    }
    lruFromRecord(cacheRecord) {
        return new lru_map_1.LRUMap(this.limit, cacheRecord.entries.map((e) => [e.key, e.value]));
    }
    async fetchCacheRecord(agentContext) {
        let cacheRecord = await this.cacheRepository.findById(agentContext, this.cacheId);
        if (!cacheRecord) {
            cacheRecord = new CacheRecord_1.CacheRecord({
                id: this.cacheId,
                entries: [],
            });
            await this.cacheRepository.save(agentContext, cacheRecord);
        }
        return cacheRecord;
    }
    async persistCache(agentContext) {
        const cache = await this.getCache(agentContext);
        await this.cacheRepository.update(agentContext, new CacheRecord_1.CacheRecord({
            entries: cache.toJSON(),
            id: this.cacheId,
        }));
    }
}
exports.PersistedLruCache = PersistedLruCache;
//# sourceMappingURL=PersistedLruCache.js.map