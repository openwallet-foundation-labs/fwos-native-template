"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyWallet = void 0;
const tsyringe_1 = require("tsyringe");
const constants_1 = require("../constants");
const crypto_1 = require("../crypto");
const Key_1 = require("../crypto/Key");
const SigningProviderRegistry_1 = require("../crypto/signing-provider/SigningProviderRegistry");
const error_1 = require("../error");
const utils_1 = require("../utils");
const JsonEncoder_1 = require("../utils/JsonEncoder");
const error_2 = require("../utils/error");
const indyError_1 = require("../utils/indyError");
const error_3 = require("./error");
const WalletInvalidKeyError_1 = require("./error/WalletInvalidKeyError");
let IndyWallet = class IndyWallet {
    constructor(agentDependencies, logger, signingKeyProviderRegistry) {
        this.logger = logger;
        this.signingKeyProviderRegistry = signingKeyProviderRegistry;
        this.indy = agentDependencies.indy;
    }
    get isProvisioned() {
        return this.walletConfig !== undefined;
    }
    get isInitialized() {
        return this.walletHandle !== undefined;
    }
    /**
     * @deprecated The public did functionality of the wallet has been deprecated in favour of the DidsModule, which can be
     * used to create and resolve dids. Currently the global agent public did functionality is still used by the `LedgerModule`, but
     * will be removed once the `LedgerModule` has been deprecated. Do not use this property for new functionality, but rather
     * use the `DidsModule`.
     */
    get publicDid() {
        return this.publicDidInfo;
    }
    get handle() {
        if (!this.walletHandle) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return this.walletHandle;
    }
    get masterSecretId() {
        var _a, _b, _c, _d;
        if (!this.isInitialized || !(((_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id) || ((_b = this.walletConfig) === null || _b === void 0 ? void 0 : _b.masterSecretId))) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return (_d = (_c = this.walletConfig) === null || _c === void 0 ? void 0 : _c.masterSecretId) !== null && _d !== void 0 ? _d : this.walletConfig.id;
    }
    /**
     * Dispose method is called when an agent context is disposed.
     */
    async dispose() {
        if (this.isInitialized) {
            await this.close();
        }
    }
    walletStorageConfig(walletConfig) {
        var _a, _b, _c;
        const walletStorageConfig = {
            id: walletConfig.id,
            storage_type: (_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.type,
        };
        if ((_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.config) {
            walletStorageConfig.storage_config = (_c = walletConfig.storage) === null || _c === void 0 ? void 0 : _c.config;
        }
        return walletStorageConfig;
    }
    walletCredentials(walletConfig, rekey, rekeyDerivation) {
        var _a, _b;
        const walletCredentials = {
            key: walletConfig.key,
            key_derivation_method: walletConfig.keyDerivationMethod,
        };
        if (rekey) {
            walletCredentials.rekey = rekey;
        }
        if (rekeyDerivation) {
            walletCredentials.rekey_derivation_method = rekeyDerivation;
        }
        if ((_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.credentials) {
            walletCredentials.storage_credentials = (_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.credentials;
        }
        return walletCredentials;
    }
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    async create(walletConfig) {
        await this.createAndOpen(walletConfig);
        await this.close();
    }
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    async createAndOpen(walletConfig) {
        this.logger.debug(`Creating wallet '${walletConfig.id}' using SQLite storage`);
        try {
            await this.indy.createWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig));
            this.walletConfig = walletConfig;
            // We usually want to create master secret only once, therefore, we can to do so when creating a wallet.
            await this.open(walletConfig);
            // We need to open wallet before creating master secret because we need wallet handle here.
            await this.createMasterSecret(this.handle, this.masterSecretId);
        }
        catch (error) {
            // If an error ocurred while creating the master secret, we should close the wallet
            if (this.isInitialized)
                await this.close();
            if ((0, indyError_1.isIndyError)(error, 'WalletAlreadyExistsError')) {
                const errorMessage = `Wallet '${walletConfig.id}' already exists`;
                this.logger.debug(errorMessage);
                throw new error_3.WalletDuplicateError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                if (!(0, error_2.isError)(error)) {
                    throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
                }
                const errorMessage = `Error creating wallet '${walletConfig.id}'`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_3.WalletError(errorMessage, { cause: error });
            }
        }
        this.logger.debug(`Successfully created wallet '${walletConfig.id}'`);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async open(walletConfig) {
        await this._open(walletConfig);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async rotateKey(walletConfig) {
        if (!walletConfig.rekey) {
            throw new error_3.WalletError('Wallet rekey undefined!. Please specify the new wallet key');
        }
        await this._open({
            id: walletConfig.id,
            key: walletConfig.key,
            keyDerivationMethod: walletConfig.keyDerivationMethod,
        }, walletConfig.rekey, walletConfig.rekeyDerivationMethod);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async _open(walletConfig, rekey, rekeyDerivation) {
        if (this.walletHandle) {
            throw new error_3.WalletError('Wallet instance already opened. Close the currently opened wallet before re-opening the wallet');
        }
        try {
            this.walletHandle = await this.indy.openWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig, rekey, rekeyDerivation));
            if (rekey) {
                this.walletConfig = Object.assign(Object.assign({}, walletConfig), { key: rekey, keyDerivationMethod: rekeyDerivation });
            }
            else {
                this.walletConfig = walletConfig;
            }
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletNotFoundError')) {
                const errorMessage = `Wallet '${walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_3.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else if ((0, indyError_1.isIndyError)(error, 'WalletAccessFailed')) {
                const errorMessage = `Incorrect key for wallet '${walletConfig.id}'`;
                this.logger.debug(errorMessage);
                throw new WalletInvalidKeyError_1.WalletInvalidKeyError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                if (!(0, error_2.isError)(error)) {
                    throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
                }
                const errorMessage = `Error opening wallet '${walletConfig.id}': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_3.WalletError(errorMessage, { cause: error });
            }
        }
        this.logger.debug(`Wallet '${walletConfig.id}' opened with handle '${this.handle}'`);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async delete() {
        if (!this.walletConfig) {
            throw new error_3.WalletError('Can not delete wallet that does not have wallet config set. Make sure to call create wallet before deleting the wallet');
        }
        this.logger.info(`Deleting wallet '${this.walletConfig.id}'`);
        if (this.walletHandle) {
            await this.close();
        }
        try {
            await this.indy.deleteWallet(this.walletStorageConfig(this.walletConfig), this.walletCredentials(this.walletConfig));
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletNotFoundError')) {
                const errorMessage = `Error deleting wallet: wallet '${this.walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_3.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                if (!(0, error_2.isError)(error)) {
                    throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
                }
                const errorMessage = `Error deleting wallet '${this.walletConfig.id}': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_3.WalletError(errorMessage, { cause: error });
            }
        }
    }
    async export(exportConfig) {
        var _a;
        try {
            this.logger.debug(`Exporting wallet ${(_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id} to path ${exportConfig.path}`);
            await this.indy.exportWallet(this.handle, exportConfig);
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            const errorMessage = `Error exporting wallet: ${error.message}`;
            this.logger.error(errorMessage, {
                error,
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
        }
    }
    async import(walletConfig, importConfig) {
        try {
            this.logger.debug(`Importing wallet ${walletConfig.id} from path ${importConfig.path}`);
            await this.indy.importWallet({ id: walletConfig.id }, { key: walletConfig.key, key_derivation_method: walletConfig.keyDerivationMethod }, importConfig);
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            const errorMessage = `Error importing wallet': ${error.message}`;
            this.logger.error(errorMessage, {
                error,
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
        }
    }
    /**
     * @throws {WalletError} if the wallet is already closed or another error occurs
     */
    async close() {
        var _a;
        this.logger.debug(`Closing wallet ${(_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id}`);
        if (!this.walletHandle) {
            throw new error_3.WalletError('Wallet is in invalid state, you are trying to close wallet that has no `walletHandle`.');
        }
        try {
            await this.indy.closeWallet(this.walletHandle);
            this.walletHandle = undefined;
            this.publicDidInfo = undefined;
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletInvalidHandle')) {
                const errorMessage = `Error closing wallet: wallet already closed`;
                this.logger.debug(errorMessage);
                throw new error_3.WalletError(errorMessage, {
                    cause: error,
                });
            }
            else {
                if (!(0, error_2.isError)(error)) {
                    throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
                }
                const errorMessage = `Error closing wallet': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_3.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * Create master secret with specified id in currently opened wallet.
     *
     * If a master secret by this id already exists in the current wallet, the method
     * will return without doing anything.
     *
     * @throws {WalletError} if an error occurs
     */
    async createMasterSecret(walletHandle, masterSecretId) {
        this.logger.debug(`Creating master secret with id '${masterSecretId}' in wallet with handle '${walletHandle}'`);
        try {
            await this.indy.proverCreateMasterSecret(walletHandle, masterSecretId);
            return masterSecretId;
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'AnoncredsMasterSecretDuplicateNameError')) {
                // master secret id is the same as the master secret id passed in the create function
                // so if it already exists we can just assign it.
                this.logger.debug(`Master secret with id '${masterSecretId}' already exists in wallet with handle '${walletHandle}'`, {
                    indyError: 'AnoncredsMasterSecretDuplicateNameError',
                });
                return masterSecretId;
            }
            else {
                if (!(0, indyError_1.isIndyError)(error)) {
                    throw new error_1.AriesFrameworkError('Attempted to throw Indy error, but it was not an Indy error');
                }
                this.logger.error(`Error creating master secret with id ${masterSecretId}`, {
                    indyError: error.indyName,
                    error,
                });
                throw new error_3.WalletError(`Error creating master secret with id ${masterSecretId} in wallet with handle '${walletHandle}'`, { cause: error });
            }
        }
    }
    /**
     * @deprecated The public did functionality of the wallet has been deprecated in favour of the DidsModule, which can be
     * used to create and resolve dids. Currently the global agent public did functionality is still used by the `LedgerModule`, but
     * will be removed once the `LedgerModule` has been deprecated. Do not use this property for new functionality, but rather
     * use the `DidsModule`.
     */
    async initPublicDid(didConfig) {
        // The Indy SDK cannot use a key to sign a request for the ledger. This is the only place where we need to call createDid
        try {
            const [did, verkey] = await this.indy.createAndStoreMyDid(this.handle, didConfig || {});
            this.publicDidInfo = {
                did,
                verkey,
            };
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError('Error creating Did', { cause: error });
        }
    }
    /**
     * Create a key with an optional seed and keyType.
     * The keypair is also automatically stored in the wallet afterwards
     *
     * Bls12381g1g2 and X25519 are not supported.
     *
     * @param seed string The seed for creating a key
     * @param keyType KeyType the type of key that should be created
     *
     * @returns a Key instance with a publicKeyBase58
     *
     * @throws {WalletError} When an unsupported keytype is requested
     * @throws {WalletError} When the key could not be created
     */
    async createKey({ seed, keyType }) {
        try {
            // Ed25519 is supported natively in Indy wallet
            if (keyType === crypto_1.KeyType.Ed25519) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                //@ts-ignore
                const verkey = await this.indy.createKey(this.handle, { seed, crypto_type: 'ed25519' });
                return Key_1.Key.fromPublicKeyBase58(verkey, keyType);
            }
            // Check if there is a signing key provider for the specified key type.
            if (this.signingKeyProviderRegistry.hasProviderForKeyType(keyType)) {
                const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(keyType);
                const keyPair = await signingKeyProvider.createKeyPair({ seed });
                await this.storeKeyPair(keyPair);
                return Key_1.Key.fromPublicKeyBase58(keyPair.publicKeyBase58, keyType);
            }
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError(`Error creating key with key type '${keyType}': ${error.message}`, { cause: error });
        }
        throw new error_3.WalletError(`Unsupported key type: '${keyType}' for wallet IndyWallet`);
    }
    /**
     * sign a Buffer with an instance of a Key class
     *
     * Bls12381g1g2, Bls12381g1 and X25519 are not supported.
     *
     * @param data Buffer The data that needs to be signed
     * @param key Key The key that is used to sign the data
     *
     * @returns A signature for the data
     */
    async sign({ data, key }) {
        try {
            // Ed25519 is supported natively in Indy wallet
            if (key.keyType === crypto_1.KeyType.Ed25519) {
                // Checks to see if it is an not an Array of messages, but just a single one
                if (!utils_1.TypedArrayEncoder.isTypedArray(data)) {
                    throw new error_3.WalletError(`${crypto_1.KeyType.Ed25519} does not support multiple singing of multiple messages`);
                }
                return await this.indy.cryptoSign(this.handle, key.publicKeyBase58, data);
            }
            // Check if there is a signing key provider for the specified key type.
            if (this.signingKeyProviderRegistry.hasProviderForKeyType(key.keyType)) {
                const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(key.keyType);
                const keyPair = await this.retrieveKeyPair(key.publicKeyBase58);
                const signed = await signingKeyProvider.sign({
                    data,
                    privateKeyBase58: keyPair.privateKeyBase58,
                    publicKeyBase58: key.publicKeyBase58,
                });
                return signed;
            }
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError(`Error signing data with verkey ${key.publicKeyBase58}`, { cause: error });
        }
        throw new error_3.WalletError(`Unsupported keyType: ${key.keyType}`);
    }
    /**
     * Verify the signature with the data and the used key
     *
     * Bls12381g1g2, Bls12381g1 and X25519 are not supported.
     *
     * @param data Buffer The data that has to be confirmed to be signed
     * @param key Key The key that was used in the signing process
     * @param signature Buffer The signature that was created by the signing process
     *
     * @returns A boolean whether the signature was created with the supplied data and key
     *
     * @throws {WalletError} When it could not do the verification
     * @throws {WalletError} When an unsupported keytype is used
     */
    async verify({ data, key, signature }) {
        try {
            // Ed25519 is supported natively in Indy wallet
            if (key.keyType === crypto_1.KeyType.Ed25519) {
                // Checks to see if it is an not an Array of messages, but just a single one
                if (!utils_1.TypedArrayEncoder.isTypedArray(data)) {
                    throw new error_3.WalletError(`${crypto_1.KeyType.Ed25519} does not support multiple singing of multiple messages`);
                }
                return await this.indy.cryptoVerify(key.publicKeyBase58, data, signature);
            }
            // Check if there is a signing key provider for the specified key type.
            if (this.signingKeyProviderRegistry.hasProviderForKeyType(key.keyType)) {
                const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(key.keyType);
                const signed = await signingKeyProvider.verify({
                    data,
                    signature,
                    publicKeyBase58: key.publicKeyBase58,
                });
                return signed;
            }
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError(`Error verifying signature of data signed with verkey ${key.publicKeyBase58}`, {
                cause: error,
            });
        }
        throw new error_3.WalletError(`Unsupported keyType: ${key.keyType}`);
    }
    async pack(payload, recipientKeys, senderVerkey) {
        try {
            const messageRaw = JsonEncoder_1.JsonEncoder.toBuffer(payload);
            const packedMessage = await this.indy.packMessage(this.handle, messageRaw, recipientKeys, senderVerkey !== null && senderVerkey !== void 0 ? senderVerkey : null);
            return JsonEncoder_1.JsonEncoder.fromBuffer(packedMessage);
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError('Error packing message', { cause: error });
        }
    }
    async unpack(messagePackage) {
        try {
            const unpackedMessageBuffer = await this.indy.unpackMessage(this.handle, JsonEncoder_1.JsonEncoder.toBuffer(messagePackage));
            const unpackedMessage = JsonEncoder_1.JsonEncoder.fromBuffer(unpackedMessageBuffer);
            return {
                senderKey: unpackedMessage.sender_verkey,
                recipientKey: unpackedMessage.recipient_verkey,
                plaintextMessage: JsonEncoder_1.JsonEncoder.fromString(unpackedMessage.message),
            };
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError('Error unpacking message', { cause: error });
        }
    }
    async generateNonce() {
        try {
            return await this.indy.generateNonce();
        }
        catch (error) {
            if (!(0, error_2.isError)(error)) {
                throw new error_1.AriesFrameworkError('Attempted to throw error, but it was not of type Error');
            }
            throw new error_3.WalletError('Error generating nonce', { cause: error });
        }
    }
    async retrieveKeyPair(publicKeyBase58) {
        try {
            const { value } = await this.indy.getWalletRecord(this.handle, 'KeyPairRecord', `key-${publicKeyBase58}`, {});
            if (value) {
                return JsonEncoder_1.JsonEncoder.fromString(value);
            }
            else {
                throw new error_3.WalletError(`No content found for record with public key: ${publicKeyBase58}`);
            }
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`KeyPairRecord not found for public key: ${publicKeyBase58}.`, {
                    recordType: 'KeyPairRecord',
                    cause: error,
                });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async storeKeyPair(keyPair) {
        try {
            await this.indy.addWalletRecord(this.handle, 'KeyPairRecord', `key-${keyPair.publicKeyBase58}`, JSON.stringify(keyPair), {
                keyType: keyPair.keyType,
            });
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error, 'WalletItemAlreadyExists')) {
                throw new error_1.RecordDuplicateError(`Record already exists`, { recordType: 'KeyPairRecord' });
            }
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async generateWalletKey() {
        try {
            return await this.indy.generateWalletKey();
        }
        catch (error) {
            throw new error_3.WalletError('Error generating wallet key', { cause: error });
        }
    }
};
IndyWallet = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
    __param(1, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Logger)),
    __metadata("design:paramtypes", [Object, Object, SigningProviderRegistry_1.SigningProviderRegistry])
], IndyWallet);
exports.IndyWallet = IndyWallet;
//# sourceMappingURL=IndyWallet.js.map