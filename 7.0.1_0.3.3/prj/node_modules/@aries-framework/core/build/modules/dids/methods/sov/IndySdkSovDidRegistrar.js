"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndySdkSovDidRegistrar = void 0;
const error_1 = require("../../../../error");
const plugins_1 = require("../../../../plugins");
const indyError_1 = require("../../../../utils/indyError");
const assertIndyWallet_1 = require("../../../../wallet/util/assertIndyWallet");
const ledger_1 = require("../../../ledger");
const DidDocumentRole_1 = require("../../domain/DidDocumentRole");
const repository_1 = require("../../repository");
const util_1 = require("./util");
let IndySdkSovDidRegistrar = class IndySdkSovDidRegistrar {
    constructor() {
        this.supportedMethods = ['sov'];
    }
    async create(agentContext, options) {
        var _a, _b;
        const indy = agentContext.config.agentDependencies.indy;
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        const { alias, role, submitterDid, indyNamespace } = options.options;
        const seed = (_a = options.secret) === null || _a === void 0 ? void 0 : _a.seed;
        if (seed && (typeof seed !== 'string' || seed.length !== 32)) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: 'Invalid seed provided',
                },
            };
        }
        if (!submitterDid.startsWith('did:sov:')) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: 'Submitter did must be a valid did:sov did',
                },
            };
        }
        try {
            // NOTE: we need to use the createAndStoreMyDid method from indy to create the did
            // If we just create a key and handle the creating of the did ourselves, indy will throw a
            // WalletItemNotFound when it needs to sign ledger transactions using this did. This means we need
            // to rely directly on the indy SDK, as we don't want to expose a createDid method just for.
            // FIXME: once askar/indy-vdr is supported we need to adjust this to work with both indy-sdk and askar
            (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
            const [unqualifiedIndyDid, verkey] = await indy.createAndStoreMyDid(agentContext.wallet.handle, {
                seed,
            });
            const qualifiedSovDid = `did:sov:${unqualifiedIndyDid}`;
            const unqualifiedSubmitterDid = submitterDid.replace('did:sov:', '');
            // TODO: it should be possible to pass the pool used for writing to the indy ledger service.
            // The easiest way to do this would be to make the submitterDid a fully qualified did, including the indy namespace.
            const pool = indyPoolService.getPoolForNamespace(indyNamespace);
            await this.registerPublicDid(agentContext, unqualifiedSubmitterDid, unqualifiedIndyDid, verkey, alias, pool, role);
            // Create did document
            const didDocumentBuilder = (0, util_1.sovDidDocumentFromDid)(qualifiedSovDid, verkey);
            // Add services if endpoints object was passed.
            if (options.options.endpoints) {
                await this.setEndpointsForDid(agentContext, unqualifiedIndyDid, options.options.endpoints, pool);
                (0, util_1.addServicesFromEndpointsAttrib)(didDocumentBuilder, qualifiedSovDid, options.options.endpoints, `${qualifiedSovDid}#key-agreement-1`);
            }
            // Build did document.
            const didDocument = didDocumentBuilder.build();
            const didIndyNamespace = pool.config.indyNamespace;
            const qualifiedIndyDid = `did:indy:${didIndyNamespace}:${unqualifiedIndyDid}`;
            // Save the did so we know we created it and can issue with it
            const didRecord = new repository_1.DidRecord({
                did: qualifiedSovDid,
                role: DidDocumentRole_1.DidDocumentRole.Created,
                tags: {
                    recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
                    qualifiedIndyDid,
                },
            });
            await didRepository.save(agentContext, didRecord);
            return {
                didDocumentMetadata: {
                    qualifiedIndyDid,
                },
                didRegistrationMetadata: {
                    didIndyNamespace,
                },
                didState: {
                    state: 'finished',
                    did: qualifiedSovDid,
                    didDocument,
                    secret: {
                        // FIXME: the uni-registrar creates the seed in the registrar method
                        // if it doesn't exist so the seed can always be returned. Currently
                        // we can only return it if the seed was passed in by the user. Once
                        // we have a secure method for generating seeds we should use the same
                        // approach
                        seed: (_b = options.secret) === null || _b === void 0 ? void 0 : _b.seed,
                    },
                },
            };
        }
        catch (error) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: `unknownError: ${error.message}`,
                },
            };
        }
    }
    async update() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notImplemented: updating did:sov not implemented yet`,
            },
        };
    }
    async deactivate() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notImplemented: deactivating did:sov not implemented yet`,
            },
        };
    }
    async registerPublicDid(agentContext, submitterDid, targetDid, verkey, alias, pool, role) {
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const indy = agentContext.config.agentDependencies.indy;
        try {
            agentContext.config.logger.debug(`Register public did '${targetDid}' on ledger '${pool.id}'`);
            const request = await indy.buildNymRequest(submitterDid, targetDid, verkey, alias, role || null);
            const response = await indyPoolService.submitWriteRequest(agentContext, pool, request, submitterDid);
            agentContext.config.logger.debug(`Registered public did '${targetDid}' on ledger '${pool.id}'`, {
                response,
            });
            return targetDid;
        }
        catch (error) {
            agentContext.config.logger.error(`Error registering public did '${targetDid}' on ledger '${pool.id}'`, {
                error,
                submitterDid,
                targetDid,
                verkey,
                alias,
                role,
                pool: pool.id,
            });
            throw error;
        }
    }
    async setEndpointsForDid(agentContext, did, endpoints, pool) {
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const indy = agentContext.config.agentDependencies.indy;
        try {
            agentContext.config.logger.debug(`Set endpoints for did '${did}' on ledger '${pool.id}'`, endpoints);
            const request = await indy.buildAttribRequest(did, did, null, { endpoint: endpoints }, null);
            const response = await indyPoolService.submitWriteRequest(agentContext, pool, request, did);
            agentContext.config.logger.debug(`Successfully set endpoints for did '${did}' on ledger '${pool.id}'`, {
                response,
                endpoints,
            });
        }
        catch (error) {
            agentContext.config.logger.error(`Error setting endpoints for did '${did}' on ledger '${pool.id}'`, {
                error,
                did,
                endpoints,
            });
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
};
IndySdkSovDidRegistrar = __decorate([
    (0, plugins_1.injectable)()
], IndySdkSovDidRegistrar);
exports.IndySdkSovDidRegistrar = IndySdkSovDidRegistrar;
//# sourceMappingURL=IndySdkSovDidRegistrar.js.map