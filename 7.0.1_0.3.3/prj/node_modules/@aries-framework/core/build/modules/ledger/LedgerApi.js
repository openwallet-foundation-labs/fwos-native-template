"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerApi = void 0;
const agent_1 = require("../../agent");
const error_1 = require("../../error");
const IndySdkError_1 = require("../../error/IndySdkError");
const plugins_1 = require("../../plugins");
const indyError_1 = require("../../utils/indyError");
const indyIdentifiers_1 = require("../../utils/indyIdentifiers");
const AnonCredsCredentialDefinitionRecord_1 = require("../indy/repository/AnonCredsCredentialDefinitionRecord");
const AnonCredsCredentialDefinitionRepository_1 = require("../indy/repository/AnonCredsCredentialDefinitionRepository");
const AnonCredsSchemaRecord_1 = require("../indy/repository/AnonCredsSchemaRecord");
const AnonCredsSchemaRepository_1 = require("../indy/repository/AnonCredsSchemaRepository");
const LedgerModuleConfig_1 = require("./LedgerModuleConfig");
const services_1 = require("./services");
let LedgerApi = class LedgerApi {
    constructor(ledgerService, agentContext, anonCredsCredentialDefinitionRepository, anonCredsSchemaRepository, config) {
        this.ledgerService = ledgerService;
        this.agentContext = agentContext;
        this.anonCredsCredentialDefinitionRepository = anonCredsCredentialDefinitionRepository;
        this.anonCredsSchemaRepository = anonCredsSchemaRepository;
        this.config = config;
    }
    setPools(poolConfigs) {
        return this.ledgerService.setPools(poolConfigs);
    }
    /**
     * Connect to all the ledger pools
     */
    async connectToPools() {
        await this.ledgerService.connectToPools();
    }
    /**
     * @deprecated use agent.dids.create instead
     */
    async registerPublicDid(did, verkey, alias, role) {
        var _a;
        const myPublicDid = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!myPublicDid) {
            throw new error_1.AriesFrameworkError('Agent has no public DID.');
        }
        return this.ledgerService.registerPublicDid(this.agentContext, myPublicDid, did, verkey, alias, role);
    }
    /**
     * @deprecated use agent.dids.resolve instead
     */
    async getPublicDid(did) {
        return this.ledgerService.getPublicDid(this.agentContext, did);
    }
    async getSchema(id) {
        return this.ledgerService.getSchema(this.agentContext, id);
    }
    async registerSchema(schema) {
        var _a;
        const did = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!did) {
            throw new error_1.AriesFrameworkError('Agent has no public DID.');
        }
        const schemaId = (0, indyIdentifiers_1.getLegacySchemaId)(did, schema.name, schema.version);
        // Generate the qualified ID
        const qualifiedIdentifier = (0, indyIdentifiers_1.getQualifiedIndySchemaId)(this.ledgerService.getDidIndyWriteNamespace(), schemaId);
        // Try find the schema in the wallet
        const schemaRecord = await this.anonCredsSchemaRepository.findById(this.agentContext, qualifiedIdentifier);
        // Schema in wallet
        if (schemaRecord) {
            // Transform qualified to unqualified
            return Object.assign(Object.assign({}, schemaRecord.schema), { id: schemaId });
        }
        const schemaFromLedger = await this.findBySchemaIdOnLedger(schemaId);
        if (schemaFromLedger)
            return schemaFromLedger;
        const createdSchema = await this.ledgerService.registerSchema(this.agentContext, did, schema);
        const anonCredsSchema = new AnonCredsSchemaRecord_1.AnonCredsSchemaRecord({
            schema: Object.assign(Object.assign({}, createdSchema), { id: qualifiedIdentifier }),
        });
        await this.anonCredsSchemaRepository.save(this.agentContext, anonCredsSchema);
        return createdSchema;
    }
    async findBySchemaIdOnLedger(schemaId) {
        try {
            return await this.ledgerService.getSchema(this.agentContext, schemaId);
        }
        catch (e) {
            if (e instanceof IndySdkError_1.IndySdkError && (0, indyError_1.isIndyError)(e.cause, 'LedgerNotFound'))
                return null;
            throw e;
        }
    }
    async findByCredentialDefinitionIdOnLedger(credentialDefinitionId) {
        try {
            return await this.ledgerService.getCredentialDefinition(this.agentContext, credentialDefinitionId);
        }
        catch (e) {
            if (e instanceof IndySdkError_1.IndySdkError && (0, indyError_1.isIndyError)(e.cause, 'LedgerNotFound'))
                return null;
            throw e;
        }
    }
    async registerCredentialDefinition(credentialDefinitionTemplate) {
        var _a;
        const did = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!did) {
            throw new error_1.AriesFrameworkError('Agent has no public DID.');
        }
        // Construct credential definition ID
        const credentialDefinitionId = (0, indyIdentifiers_1.getLegacyCredentialDefinitionId)(did, credentialDefinitionTemplate.schema.seqNo, credentialDefinitionTemplate.tag);
        // Construct qualified identifier
        const qualifiedIdentifier = (0, indyIdentifiers_1.getQualifiedIndyCredentialDefinitionId)(this.ledgerService.getDidIndyWriteNamespace(), credentialDefinitionId);
        // Check if the credential exists in wallet. If so, return it
        const credentialDefinitionRecord = await this.anonCredsCredentialDefinitionRepository.findById(this.agentContext, qualifiedIdentifier);
        // Credential Definition in wallet
        if (credentialDefinitionRecord) {
            // Transform qualified to unqualified
            return Object.assign(Object.assign({}, credentialDefinitionRecord.credentialDefinition), { id: credentialDefinitionId });
        }
        // Check for the credential on the ledger.
        const credentialDefinitionOnLedger = await this.findByCredentialDefinitionIdOnLedger(credentialDefinitionId);
        if (credentialDefinitionOnLedger) {
            throw new error_1.AriesFrameworkError(`No credential definition record found and credential definition ${credentialDefinitionId} already exists on the ledger.`);
        }
        // Register the credential
        const registeredDefinition = await this.ledgerService.registerCredentialDefinition(this.agentContext, did, Object.assign(Object.assign({}, credentialDefinitionTemplate), { signatureType: 'CL' }));
        // Replace the unqualified with qualified Identifier in anonCred
        const anonCredCredential = new AnonCredsCredentialDefinitionRecord_1.AnonCredsCredentialDefinitionRecord({
            credentialDefinition: Object.assign(Object.assign({}, registeredDefinition), { id: qualifiedIdentifier }),
        });
        await this.anonCredsCredentialDefinitionRepository.save(this.agentContext, anonCredCredential);
        return registeredDefinition;
    }
    async getCredentialDefinition(id) {
        return this.ledgerService.getCredentialDefinition(this.agentContext, id);
    }
    async getRevocationRegistryDefinition(revocationRegistryDefinitionId) {
        return this.ledgerService.getRevocationRegistryDefinition(this.agentContext, revocationRegistryDefinitionId);
    }
    async getRevocationRegistryDelta(revocationRegistryDefinitionId, fromSeconds = 0, toSeconds = new Date().getTime()) {
        return this.ledgerService.getRevocationRegistryDelta(this.agentContext, revocationRegistryDefinitionId, fromSeconds, toSeconds);
    }
};
LedgerApi = __decorate([
    (0, plugins_1.injectable)(),
    __metadata("design:paramtypes", [services_1.IndyLedgerService,
        agent_1.AgentContext,
        AnonCredsCredentialDefinitionRepository_1.AnonCredsCredentialDefinitionRepository,
        AnonCredsSchemaRepository_1.AnonCredsSchemaRepository,
        LedgerModuleConfig_1.LedgerModuleConfig])
], LedgerApi);
exports.LedgerApi = LedgerApi;
//# sourceMappingURL=LedgerApi.js.map