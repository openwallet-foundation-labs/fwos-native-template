"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyPool = void 0;
const error_1 = require("../../error");
const indyError_1 = require("../../utils/indyError");
const LedgerError_1 = require("./error/LedgerError");
const ledgerUtil_1 = require("./ledgerUtil");
class IndyPool {
    constructor(poolConfig, agentDependencies, logger, stop$, fileSystem) {
        this.indy = agentDependencies.indy;
        this.fileSystem = fileSystem;
        this.poolConfig = poolConfig;
        this.logger = logger;
        // Listen to stop$ (shutdown) and close pool
        stop$.subscribe(async () => {
            if (this._poolHandle) {
                await this.close();
            }
        });
    }
    get didIndyNamespace() {
        return this.didIndyNamespace;
    }
    get id() {
        return this.poolConfig.id;
    }
    get config() {
        return this.poolConfig;
    }
    async close() {
        const poolHandle = this._poolHandle;
        if (!poolHandle) {
            return;
        }
        this._poolHandle = undefined;
        this.poolConnected = undefined;
        await this.indy.closePoolLedger(poolHandle);
    }
    async delete() {
        // Close the pool if currently open
        if (this._poolHandle) {
            await this.close();
        }
        await this.indy.deletePoolLedgerConfig(this.poolConfig.id);
    }
    async connect() {
        if (!this.poolConnected) {
            // Save the promise of connectToLedger to determine if we are done connecting
            this.poolConnected = this.connectToLedger();
            this.poolConnected.catch((error) => {
                // Set poolConnected to undefined so we can retry connection upon failure
                this.poolConnected = undefined;
                this.logger.error('Connection to pool: ' + this.poolConfig.genesisPath + ' failed.', { error });
            });
            return this.poolConnected;
        }
        else {
            throw new error_1.AriesFrameworkError('Cannot attempt connection to ledger, already connecting.');
        }
    }
    async connectToLedger() {
        const poolName = this.poolConfig.id;
        const genesisPath = await this.getGenesisPath();
        if (!genesisPath) {
            throw new error_1.AriesFrameworkError('Cannot connect to ledger without genesis file');
        }
        this.logger.debug(`Connecting to ledger pool '${poolName}'`, { genesisPath });
        await this.indy.setProtocolVersion(2);
        try {
            this._poolHandle = await this.indy.openPoolLedger(poolName);
            return this._poolHandle;
        }
        catch (error) {
            if (!(0, indyError_1.isIndyError)(error, 'PoolLedgerNotCreatedError')) {
                throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
            }
        }
        this.logger.debug(`Pool '${poolName}' does not exist yet, creating.`, {
            indyError: 'PoolLedgerNotCreatedError',
        });
        try {
            await this.indy.createPoolLedgerConfig(poolName, { genesis_txn: genesisPath });
            this._poolHandle = await this.indy.openPoolLedger(poolName);
            return this._poolHandle;
        }
        catch (error) {
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async submitRequest(request) {
        return this.indy.submitRequest(await this.getPoolHandle(), request);
    }
    async submitReadRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, ledgerUtil_1.isLedgerRejectResponse)(response) || (0, ledgerUtil_1.isLedgerReqnackResponse)(response)) {
            throw new LedgerError_1.LedgerError(`Ledger '${this.id}' rejected read transaction request: ${response.reason}`);
        }
        return response;
    }
    async submitWriteRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, ledgerUtil_1.isLedgerRejectResponse)(response) || (0, ledgerUtil_1.isLedgerReqnackResponse)(response)) {
            throw new LedgerError_1.LedgerError(`Ledger '${this.id}' rejected write transaction request: ${response.reason}`);
        }
        return response;
    }
    async getPoolHandle() {
        if (this.poolConnected) {
            // If we have tried to already connect to pool wait for it
            try {
                await this.poolConnected;
            }
            catch (error) {
                this.logger.error('Connection to pool: ' + this.poolConfig.genesisPath + ' failed.', { error });
            }
        }
        if (!this._poolHandle) {
            return this.connect();
        }
        return this._poolHandle;
    }
    async getGenesisPath() {
        // If the path is already provided return it
        if (this.poolConfig.genesisPath)
            return this.poolConfig.genesisPath;
        // Determine the genesisPath
        const genesisPath = this.fileSystem.basePath + `/afj/genesis-${this.poolConfig.id}.txn`;
        // Store genesis data if provided
        if (this.poolConfig.genesisTransactions) {
            await this.fileSystem.write(genesisPath, this.poolConfig.genesisTransactions);
            this.poolConfig.genesisPath = genesisPath;
            return genesisPath;
        }
        // No genesisPath
        return null;
    }
}
exports.IndyPool = IndyPool;
//# sourceMappingURL=IndyPool.js.map