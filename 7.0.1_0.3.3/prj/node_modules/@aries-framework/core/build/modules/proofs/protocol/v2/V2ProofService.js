"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.V2ProofService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../../agent/EventEmitter");
const constants_1 = require("../../../../constants");
const error_1 = require("../../../../error");
const storage_1 = require("../../../../storage");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const common_1 = require("../../../common");
const connections_1 = require("../../../connections");
const ProofService_1 = require("../../ProofService");
const PresentationProblemReportReason_1 = require("../../errors/PresentationProblemReportReason");
const ProofFormatConstants_1 = require("../../formats/ProofFormatConstants");
const IndyProofFormatService_1 = require("../../formats/indy/IndyProofFormatService");
const ProofState_1 = require("../../models/ProofState");
const repository_1 = require("../../repository");
const errors_1 = require("./errors");
const V2PresentationAckHandler_1 = require("./handlers/V2PresentationAckHandler");
const V2PresentationHandler_1 = require("./handlers/V2PresentationHandler");
const V2PresentationProblemReportHandler_1 = require("./handlers/V2PresentationProblemReportHandler");
const V2ProposePresentationHandler_1 = require("./handlers/V2ProposePresentationHandler");
const V2RequestPresentationHandler_1 = require("./handlers/V2RequestPresentationHandler");
const messages_1 = require("./messages");
const V2PresentationMessage_1 = require("./messages/V2PresentationMessage");
const V2PresentationProblemReportMessage_1 = require("./messages/V2PresentationProblemReportMessage");
const V2ProposalPresentationMessage_1 = require("./messages/V2ProposalPresentationMessage");
const V2RequestPresentationMessage_1 = require("./messages/V2RequestPresentationMessage");
let V2ProofService = class V2ProofService extends ProofService_1.ProofService {
    constructor(agentConfig, connectionService, proofRepository, didCommMessageRepository, eventEmitter, indyProofFormatService, wallet) {
        super(agentConfig, proofRepository, connectionService, didCommMessageRepository, wallet, eventEmitter);
        /**
         * The version of the present proof protocol this service supports
         */
        this.version = 'v2';
        this.wallet = wallet;
        // Dynamically build format service map. This will be extracted once services are registered dynamically
        this.formatServiceMap = [indyProofFormatService].reduce((formatServiceMap, formatService) => (Object.assign(Object.assign({}, formatServiceMap), { [formatService.formatKey]: formatService })), {});
    }
    async createProposal(agentContext, options) {
        var _a;
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
            const service = this.formatServiceMap[key];
            formats.push(await service.createProposal({ formats: options.proofFormats }));
        }
        const proposalMessage = new V2ProposalPresentationMessage_1.V2ProposalPresentationMessage({
            attachmentInfo: formats,
            comment: options.comment,
            willConfirm: options.willConfirm,
            goalCode: options.goalCode,
            parentThreadId: options.parentThreadId,
        });
        const proofRecord = new repository_1.ProofExchangeRecord({
            connectionId: options.connectionRecord.id,
            threadId: proposalMessage.threadId,
            parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
            state: ProofState_1.ProofState.ProposalSent,
            protocolVersion: 'v2',
        });
        await this.proofRepository.save(agentContext, proofRecord);
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: proposalMessage,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: proofRecord.id,
        });
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return {
            proofRecord: proofRecord,
            message: proposalMessage,
        };
    }
    async createProposalAsResponse(agentContext, options) {
        options.proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
            const service = this.formatServiceMap[key];
            formats.push(await service.createProposal({
                formats: options.proofFormats,
            }));
        }
        const proposalMessage = new V2ProposalPresentationMessage_1.V2ProposalPresentationMessage({
            attachmentInfo: formats,
            comment: options.comment,
            goalCode: options.goalCode,
            willConfirm: options.willConfirm,
        });
        proposalMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: proposalMessage,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: options.proofRecord.id,
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.ProposalSent);
        return { message: proposalMessage, proofRecord: options.proofRecord };
    }
    async processProposal(messageContext) {
        var _a;
        const { message: proposalMessage, connection: connectionRecord } = messageContext;
        let proofRecord;
        const proposalAttachments = proposalMessage.getAttachmentFormats();
        for (const attachmentFormat of proposalAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            await (service === null || service === void 0 ? void 0 : service.processProposal({
                proposal: attachmentFormat,
            }));
        }
        try {
            proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
                threadId: proposalMessage.threadId,
                connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            });
            const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
            });
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.RequestSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: proposalMessage,
                previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proposalMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.ProposalReceived);
        }
        catch (_b) {
            // No proof record exists with thread id
            proofRecord = new repository_1.ProofExchangeRecord({
                connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
                threadId: proposalMessage.threadId,
                parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
                state: ProofState_1.ProofState.ProposalReceived,
                protocolVersion: 'v2',
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save record
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proposalMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            await this.proofRepository.save(messageContext.agentContext, proofRecord);
            this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
    }
    async createRequest(agentContext, options) {
        var _a, _b;
        // create attachment formats
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
            const service = this.formatServiceMap[key];
            formats.push(await service.createRequest({
                formats: options.proofFormats,
            }));
        }
        // create request message
        const requestMessage = new V2RequestPresentationMessage_1.V2RequestPresentationMessage({
            attachmentInfo: formats,
            comment: options.comment,
            willConfirm: options.willConfirm,
            goalCode: options.goalCode,
            parentThreadId: options.parentThreadId,
        });
        // create & store proof record
        const proofRecord = new repository_1.ProofExchangeRecord({
            connectionId: (_a = options.connectionRecord) === null || _a === void 0 ? void 0 : _a.id,
            threadId: requestMessage.threadId,
            parentThreadId: (_b = requestMessage.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId,
            state: ProofState_1.ProofState.RequestSent,
            protocolVersion: 'v2',
        });
        await this.proofRepository.save(agentContext, proofRecord);
        // create DIDComm message
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: requestMessage,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: proofRecord.id,
        });
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return {
            proofRecord: proofRecord,
            message: requestMessage,
        };
    }
    async createRequestAsResponse(agentContext, options) {
        options.proofRecord.assertState(ProofState_1.ProofState.ProposalReceived);
        const proposal = await this.didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
        if (!proposal) {
            throw new error_1.AriesFrameworkError(`Proof record with id ${options.proofRecord.id} is missing required presentation proposal`);
        }
        // create attachment formats
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
            const service = this.formatServiceMap[key];
            const requestOptions = {
                proofFormats: options.proofFormats,
                proofRecord: options.proofRecord,
            };
            formats.push(await service.createRequestAsResponse(requestOptions));
        }
        // create request message
        const requestMessage = new V2RequestPresentationMessage_1.V2RequestPresentationMessage({
            attachmentInfo: formats,
            comment: options.comment,
            willConfirm: options.willConfirm,
            goalCode: options.goalCode,
        });
        requestMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: requestMessage,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: options.proofRecord.id,
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.RequestSent);
        return { message: requestMessage, proofRecord: options.proofRecord };
    }
    async processRequest(messageContext) {
        var _a;
        const { message: proofRequestMessage, connection: connectionRecord } = messageContext;
        const requestAttachments = proofRequestMessage.getAttachmentFormats();
        for (const attachmentFormat of requestAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            await (service === null || service === void 0 ? void 0 : service.processRequest({
                requestAttachment: attachmentFormat,
            }));
        }
        // assert
        if (proofRequestMessage.requestPresentationsAttach.length === 0) {
            throw new errors_1.V2PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${proofRequestMessage.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        this.logger.debug(`Received proof request`, proofRequestMessage);
        let proofRecord;
        try {
            proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
                threadId: proofRequestMessage.threadId,
                connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            });
            const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
            });
            const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
            });
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.ProposalSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
                previousSentMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : undefined,
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proofRequestMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Update record
            await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.RequestReceived);
        }
        catch (_b) {
            // No proof record exists with thread id
            proofRecord = new repository_1.ProofExchangeRecord({
                connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
                threadId: proofRequestMessage.threadId,
                parentThreadId: (_a = proofRequestMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
                state: ProofState_1.ProofState.RequestReceived,
                protocolVersion: 'v2',
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proofRequestMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save in repository
            await this.proofRepository.save(messageContext.agentContext, proofRecord);
            this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
    }
    async createPresentation(agentContext, options) {
        // assert state
        options.proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const proofRequest = await this.didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
            const service = this.formatServiceMap[key];
            formats.push(await service.createPresentation(agentContext, {
                attachment: proofRequest.getAttachmentByFormatIdentifier(ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST),
                proofFormats: options.proofFormats,
            }));
        }
        const presentationMessage = new V2PresentationMessage_1.V2PresentationMessage({
            comment: options.comment,
            attachmentInfo: formats,
            goalCode: options.goalCode,
            lastPresentation: options.lastPresentation,
        });
        presentationMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: presentationMessage,
            associatedRecordId: options.proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.PresentationSent);
        return { message: presentationMessage, proofRecord: options.proofRecord };
    }
    async processPresentation(messageContext) {
        const { message: presentationMessage, connection: connectionRecord } = messageContext;
        this.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
            threadId: presentationMessage.threadId,
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
        });
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : undefined,
            previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
        });
        const formatVerificationResults = [];
        for (const attachmentFormat of presentationMessage.getAttachmentFormats()) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            if (service) {
                try {
                    formatVerificationResults.push(await service.processPresentation(messageContext.agentContext, {
                        record: proofRecord,
                        formatAttachments: {
                            request: requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.getAttachmentFormats(),
                            presentation: presentationMessage.getAttachmentFormats(),
                        },
                    }));
                }
                catch (e) {
                    if (e instanceof error_1.AriesFrameworkError) {
                        throw new errors_1.V2PresentationProblemReportError(e.message, {
                            problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
                        });
                    }
                    throw e;
                }
            }
        }
        if (formatVerificationResults.length === 0) {
            throw new errors_1.V2PresentationProblemReportError('None of the received formats are supported.', {
                problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
            });
        }
        const isValid = formatVerificationResults.every((x) => x === true);
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: presentationMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver,
        });
        // Update record
        proofRecord.isVerified = isValid;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.PresentationReceived);
        return proofRecord;
    }
    async createAck(agentContext, options) {
        // assert we've received the final presentation
        const presentation = await this.didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: V2PresentationMessage_1.V2PresentationMessage,
        });
        if (!presentation.lastPresentation) {
            throw new error_1.AriesFrameworkError(`Trying to send an ack message while presentation with id ${presentation.id} indicates this is not the last presentation (presentation.lastPresentation is set to false)`);
        }
        const message = new messages_1.V2PresentationAckMessage({
            threadId: options.proofRecord.threadId,
            status: common_1.AckStatus.OK,
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.Done);
        return {
            message,
            proofRecord: options.proofRecord,
        };
    }
    async processAck(messageContext) {
        const { message: ackMessage, connection: connectionRecord } = messageContext;
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
            threadId: ackMessage.threadId,
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
        });
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2PresentationMessage_1.V2PresentationMessage,
        });
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.PresentationSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
            previousSentMessage: presentationMessage !== null && presentationMessage !== void 0 ? presentationMessage : undefined,
        });
        // Update record
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Done);
        return proofRecord;
    }
    async createProblemReport(agentContext, options) {
        const msg = new V2PresentationProblemReportMessage_1.V2PresentationProblemReportMessage({
            description: {
                code: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
                en: options.description,
            },
        });
        msg.setThread({
            threadId: options.proofRecord.threadId,
            parentThreadId: options.proofRecord.threadId,
        });
        return {
            proofRecord: options.proofRecord,
            message: msg,
        };
    }
    async processProblemReport(messageContext) {
        const { message: presentationProblemReportMessage } = messageContext;
        const connectionRecord = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${presentationProblemReportMessage.id}`);
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
            threadId: presentationProblemReportMessage.threadId,
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
        });
        proofRecord.errorMessage = `${presentationProblemReportMessage.description.code}: ${presentationProblemReportMessage.description.en}`;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Abandoned);
        return proofRecord;
    }
    async createProofRequestFromProposal(agentContext, options) {
        const proofRecordId = options.proofRecord.id;
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
        if (!proposalMessage) {
            throw new error_1.AriesFrameworkError(`Proof record with id ${proofRecordId} is missing required presentation proposal`);
        }
        const proposalAttachments = proposalMessage.getAttachmentFormats();
        let result = {};
        for (const attachmentFormat of proposalAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            if (!service) {
                throw new error_1.AriesFrameworkError('No format service found for getting requested.');
            }
            result = Object.assign(Object.assign({}, result), (await service.createProofRequestFromProposal({
                presentationAttachment: attachmentFormat.attachment,
            })));
        }
        const retVal = {
            proofRecord: options.proofRecord,
            proofFormats: result,
        };
        return retVal;
    }
    async shouldAutoRespondToProposal(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
        if (!proposal)
            return false;
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        if (!request)
            return false;
        MessageValidator_1.MessageValidator.validateSync(proposal);
        const proposalAttachments = proposal.getAttachmentFormats();
        const requestAttachments = request.getAttachmentFormats();
        const equalityResults = [];
        for (const attachmentFormat of proposalAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            equalityResults.push(service === null || service === void 0 ? void 0 : service.proposalAndRequestAreEqual(proposalAttachments, requestAttachments));
        }
        return true;
    }
    async shouldAutoRespondToRequest(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
        if (!proposal) {
            return false;
        }
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        if (!request) {
            throw new error_1.AriesFrameworkError(`Expected to find a request message for ProofExchangeRecord with id ${proofRecord.id}`);
        }
        const proposalAttachments = proposal.getAttachmentFormats();
        const requestAttachments = request.getAttachmentFormats();
        const equalityResults = [];
        for (const attachmentFormat of proposalAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            equalityResults.push(service === null || service === void 0 ? void 0 : service.proposalAndRequestAreEqual(proposalAttachments, requestAttachments));
        }
        return equalityResults.every((x) => x === true);
    }
    async shouldAutoRespondToPresentation(agentContext, proofRecord) {
        const request = await this.didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        return request.willConfirm;
    }
    async findRequestMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
    }
    async findPresentationMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: V2PresentationMessage_1.V2PresentationMessage,
        });
    }
    async findProposalMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage,
        });
    }
    async getFormatData(agentContext, proofRecordId) {
        // TODO: we could looking at fetching all record using a single query and then filtering based on the type of the message.
        const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([
            this.findProposalMessage(agentContext, proofRecordId),
            this.findRequestMessage(agentContext, proofRecordId),
            this.findPresentationMessage(agentContext, proofRecordId),
        ]);
        // Create object with the keys and the message formats/attachments. We can then loop over this in a generic
        // way so we don't have to add the same operation code four times
        const messages = {
            proposal: [proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.formats, proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.proposalsAttach],
            request: [requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.formats, requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.requestPresentationsAttach],
            presentation: [presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.formats, presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.presentationsAttach],
        };
        const formatData = {};
        // We loop through all of the message keys as defined above
        for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {
            // Message can be undefined, so we continue if it is not defined
            if (!formats || !attachments)
                continue;
            // Find all format services associated with the message
            const formatServices = this.getFormatServicesFromMessage(formats);
            const messageFormatData = {};
            // Loop through all of the format services, for each we will extract the attachment data and assign this to the object
            // using the unique format key (e.g. indy)
            for (const formatService of formatServices) {
                const attachment = this.getAttachmentForService(formatService, formats, attachments);
                messageFormatData[formatService.formatKey] = attachment.getDataAsJson();
            }
            formatData[messageKey] =
                messageFormatData;
        }
        return formatData;
    }
    getFormatServicesFromMessage(messageFormats) {
        const formatServices = new Set();
        for (const msg of messageFormats) {
            const service = this.getFormatServiceForFormat(msg);
            if (service)
                formatServices.add(service);
        }
        return Array.from(formatServices);
    }
    getAttachmentForService(proofFormatService, formats, attachments) {
        const attachmentId = this.getAttachmentIdForService(proofFormatService, formats);
        const attachment = attachments.find((attachment) => attachment.id === attachmentId);
        if (!attachment) {
            throw new error_1.AriesFrameworkError(`Attachment with id ${attachmentId} not found in attachments.`);
        }
        return attachment;
    }
    getAttachmentIdForService(proofFormatService, formats) {
        const format = formats.find((format) => proofFormatService.supportsFormat(format.format));
        if (!format)
            throw new error_1.AriesFrameworkError(`No attachment found for service ${proofFormatService.formatKey}`);
        return format.attachmentId;
    }
    async getRequestedCredentialsForProofRequest(agentContext, options) {
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage,
        });
        if (!requestMessage) {
            throw new error_1.AriesFrameworkError('No proof request found.');
        }
        const requestAttachments = requestMessage.getAttachmentFormats();
        let result = {
            proofFormats: {},
        };
        for (const attachmentFormat of requestAttachments) {
            const service = this.getFormatServiceForFormat(attachmentFormat.format);
            if (!service) {
                throw new error_1.AriesFrameworkError('No format service found for getting requested.');
            }
            result = Object.assign(Object.assign({}, result), (await service.getRequestedCredentialsForProofRequest(agentContext, {
                attachment: attachmentFormat.attachment,
                presentationProposal: undefined,
                config: options.config,
            })));
        }
        return result;
    }
    async autoSelectCredentialsForProofRequest(options) {
        let returnValue = {
            proofFormats: {},
        };
        for (const [id] of Object.entries(options.proofFormats)) {
            const service = this.formatServiceMap[id];
            const credentials = await service.autoSelectCredentialsForProofRequest(options);
            returnValue = Object.assign(Object.assign({}, returnValue), credentials);
        }
        return returnValue;
    }
    registerMessageHandlers(dispatcher, agentConfig, proofResponseCoordinator, mediationRecipientService, routingService) {
        dispatcher.registerMessageHandler(new V2ProposePresentationHandler_1.V2ProposePresentationHandler(this, agentConfig, this.didCommMessageRepository, proofResponseCoordinator));
        dispatcher.registerMessageHandler(new V2RequestPresentationHandler_1.V2RequestPresentationHandler(this, agentConfig, proofResponseCoordinator, mediationRecipientService, this.didCommMessageRepository, routingService));
        dispatcher.registerMessageHandler(new V2PresentationHandler_1.V2PresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new V2PresentationAckHandler_1.V2PresentationAckHandler(this));
        dispatcher.registerMessageHandler(new V2PresentationProblemReportHandler_1.V2PresentationProblemReportHandler(this));
    }
    getFormatServiceForFormat(format) {
        for (const service of Object.values(this.formatServiceMap)) {
            if (service.supportsFormat(format.format)) {
                return service;
            }
        }
        return null;
    }
};
V2ProofService = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(6, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig,
        connections_1.ConnectionService,
        repository_1.ProofRepository,
        storage_1.DidCommMessageRepository,
        EventEmitter_1.EventEmitter,
        IndyProofFormatService_1.IndyProofFormatService, Object])
], V2ProofService);
exports.V2ProofService = V2ProofService;
//# sourceMappingURL=V2ProofService.js.map