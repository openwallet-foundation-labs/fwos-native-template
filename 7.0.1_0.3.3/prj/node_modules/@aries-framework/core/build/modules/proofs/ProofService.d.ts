import type { ProofResponseCoordinator } from './ProofResponseCoordinator';
import type { ProofFormat } from './formats/ProofFormat';
import type { CreateProblemReportOptions } from './formats/models/ProofFormatServiceOptions';
import type { CreateAckOptions, CreatePresentationOptions, CreateProofRequestFromProposalOptions, CreateProposalAsResponseOptions, CreateProposalOptions, CreateRequestAsResponseOptions, CreateRequestOptions, DeleteProofOptions, FormatRequestedCredentialReturn, FormatRetrievedCredentialOptions, GetFormatDataReturn, GetRequestedCredentialsForProofRequestOptions, ProofRequestFromProposalOptions } from './models/ProofServiceOptions';
import type { ProofState } from './models/ProofState';
import type { ProofExchangeRecord, ProofRepository } from './repository';
import type { AgentConfig } from '../../agent/AgentConfig';
import type { AgentMessage } from '../../agent/AgentMessage';
import type { Dispatcher } from '../../agent/Dispatcher';
import type { EventEmitter } from '../../agent/EventEmitter';
import type { AgentContext } from '../../agent/context/AgentContext';
import type { InboundMessageContext } from '../../agent/models/InboundMessageContext';
import type { Logger } from '../../logger';
import type { DidCommMessageRepository, DidCommMessageRole } from '../../storage';
import type { Wallet } from '../../wallet/Wallet';
import type { ConnectionService } from '../connections/services';
import type { MediationRecipientService, RoutingService } from '../routing';
export declare abstract class ProofService<PFs extends ProofFormat[] = ProofFormat[]> {
    protected proofRepository: ProofRepository;
    protected didCommMessageRepository: DidCommMessageRepository;
    protected eventEmitter: EventEmitter;
    protected connectionService: ConnectionService;
    protected wallet: Wallet;
    protected logger: Logger;
    constructor(agentConfig: AgentConfig, proofRepository: ProofRepository, connectionService: ConnectionService, didCommMessageRepository: DidCommMessageRepository, wallet: Wallet, eventEmitter: EventEmitter);
    abstract readonly version: string;
    emitStateChangedEvent(agentContext: AgentContext, proofRecord: ProofExchangeRecord, previousState: ProofState | null): void;
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param proofRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    updateState(agentContext: AgentContext, proofRecord: ProofExchangeRecord, newState: ProofState): Promise<void>;
    update(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<void>;
    /**
     * 1. Assert (connection ready, record state)
     * 2. Create proposal message
     * 3. loop through all formats from ProposeProofOptions and call format service
     * 4. Create and store proof record
     * 5. Store proposal message
     * 6. Return proposal message + proof record
     */
    abstract createProposal(agentContext: AgentContext, options: CreateProposalOptions<PFs>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    /**
     * Create a proposal message in response to a received proof request message
     *
     * 1. assert record state
     * 2. Create proposal message
     * 3. loop through all formats from ProposeProofOptions and call format service
     * 4. Update proof record
     * 5. Create or update proposal message
     * 6. Return proposal message + proof record
     */
    abstract createProposalAsResponse(agentContext: AgentContext, options: CreateProposalAsResponseOptions<PFs>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    /**
     * Process a received proposal message (does not accept yet)
     *
     * 1. Find proof record by thread and connection id
     *
     * Two flows possible:
     * - Proof record already exist
     *    2. Assert state
     *    3. Save or update proposal message in storage (didcomm message record)
     *    4. Loop through all format services to process proposal message
     *    5. Update & return record
     *
     * - Proof record does not exist yet
     *    2. Create record
     *    3. Save proposal message
     *    4. Loop through all format services to process proposal message
     *    5. Save & return record
     */
    abstract processProposal(messageContext: InboundMessageContext<AgentMessage>): Promise<ProofExchangeRecord>;
    abstract createRequest(agentContext: AgentContext, options: CreateRequestOptions<PFs>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    abstract createRequestAsResponse(agentContext: AgentContext, options: CreateRequestAsResponseOptions<PFs>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    abstract processRequest(messageContext: InboundMessageContext<AgentMessage>): Promise<ProofExchangeRecord>;
    abstract createPresentation(agentContext: AgentContext, options: CreatePresentationOptions<PFs>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    abstract processPresentation(messageContext: InboundMessageContext<AgentMessage>): Promise<ProofExchangeRecord>;
    abstract createAck(agentContext: AgentContext, options: CreateAckOptions): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    abstract processAck(messageContext: InboundMessageContext<AgentMessage>): Promise<ProofExchangeRecord>;
    abstract createProblemReport(agentContext: AgentContext, options: CreateProblemReportOptions): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    abstract processProblemReport(messageContext: InboundMessageContext<AgentMessage>): Promise<ProofExchangeRecord>;
    abstract shouldAutoRespondToProposal(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    abstract shouldAutoRespondToRequest(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    abstract shouldAutoRespondToPresentation(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    abstract registerMessageHandlers(dispatcher: Dispatcher, agentConfig: AgentConfig, proofResponseCoordinator: ProofResponseCoordinator, mediationRecipientService: MediationRecipientService, routingService: RoutingService): void;
    abstract findProposalMessage(agentContext: AgentContext, proofRecordId: string): Promise<AgentMessage | null>;
    abstract findRequestMessage(agentContext: AgentContext, proofRecordId: string): Promise<AgentMessage | null>;
    abstract findPresentationMessage(agentContext: AgentContext, proofRecordId: string): Promise<AgentMessage | null>;
    saveOrUpdatePresentationMessage(agentContext: AgentContext, options: {
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
        role: DidCommMessageRole;
    }): Promise<void>;
    delete(agentContext: AgentContext, proofRecord: ProofExchangeRecord, options?: DeleteProofOptions): Promise<void>;
    abstract getRequestedCredentialsForProofRequest(agentContext: AgentContext, options: GetRequestedCredentialsForProofRequestOptions): Promise<FormatRetrievedCredentialOptions<PFs>>;
    abstract autoSelectCredentialsForProofRequest(options: FormatRetrievedCredentialOptions<PFs>): Promise<FormatRequestedCredentialReturn<PFs>>;
    abstract createProofRequestFromProposal(agentContext: AgentContext, options: CreateProofRequestFromProposalOptions): Promise<ProofRequestFromProposalOptions<PFs>>;
    abstract getFormatData(agentContext: AgentContext, proofRecordId: string): Promise<GetFormatDataReturn<PFs>>;
}
