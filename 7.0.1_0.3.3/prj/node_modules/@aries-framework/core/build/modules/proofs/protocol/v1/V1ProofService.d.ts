import type { AgentContext } from '../../../../agent';
import type { AgentMessage } from '../../../../agent/AgentMessage';
import type { Dispatcher } from '../../../../agent/Dispatcher';
import type { InboundMessageContext } from '../../../../agent/models/InboundMessageContext';
import type { Attachment } from '../../../../decorators/attachment/Attachment';
import type { MediationRecipientService } from '../../../routing/services/MediationRecipientService';
import type { RoutingService } from '../../../routing/services/RoutingService';
import type { ProofResponseCoordinator } from '../../ProofResponseCoordinator';
import type { ProofFormat } from '../../formats/ProofFormat';
import type { IndyProofFormat } from '../../formats/indy/IndyProofFormat';
import type { CreateProblemReportOptions } from '../../formats/models/ProofFormatServiceOptions';
import type { CreateAckOptions, CreatePresentationOptions, CreateProofRequestFromProposalOptions, CreateProposalAsResponseOptions, CreateProposalOptions, CreateRequestAsResponseOptions, CreateRequestOptions, FormatRequestedCredentialReturn, FormatRetrievedCredentialOptions, GetFormatDataReturn, GetRequestedCredentialsForProofRequestOptions, ProofRequestFromProposalOptions } from '../../models/ProofServiceOptions';
import { AgentConfig } from '../../../../agent/AgentConfig';
import { EventEmitter } from '../../../../agent/EventEmitter';
import { DidCommMessageRepository } from '../../../../storage/didcomm/DidCommMessageRepository';
import { Wallet } from '../../../../wallet';
import { ConnectionService } from '../../../connections';
import { CredentialRepository } from '../../../credentials';
import { IndyHolderService, IndyRevocationService } from '../../../indy';
import { IndyLedgerService } from '../../../ledger/services/IndyLedgerService';
import { ProofService } from '../../ProofService';
import { IndyProofFormatService } from '../../formats/indy/IndyProofFormatService';
import { ProofRequest } from '../../formats/indy/models/ProofRequest';
import { RequestedCredentials } from '../../formats/indy/models/RequestedCredentials';
import { ProofExchangeRecord } from '../../repository/ProofExchangeRecord';
import { ProofRepository } from '../../repository/ProofRepository';
import { V1PresentationAckMessage, V1PresentationMessage, V1ProposePresentationMessage, V1RequestPresentationMessage } from './messages';
import { V1PresentationProblemReportMessage } from './messages/V1PresentationProblemReportMessage';
/**
 * @todo add method to check if request matches proposal. Useful to see if a request I received is the same as the proposal I sent.
 * @todo add method to reject / revoke messages
 * @todo validate attachments / messages
 */
export declare class V1ProofService extends ProofService<[IndyProofFormat]> {
    private credentialRepository;
    private ledgerService;
    private indyHolderService;
    private indyRevocationService;
    private indyProofFormatService;
    constructor(proofRepository: ProofRepository, didCommMessageRepository: DidCommMessageRepository, ledgerService: IndyLedgerService, wallet: Wallet, agentConfig: AgentConfig, connectionService: ConnectionService, eventEmitter: EventEmitter, credentialRepository: CredentialRepository, formatService: IndyProofFormatService, indyHolderService: IndyHolderService, indyRevocationService: IndyRevocationService);
    /**
     * The version of the present proof protocol this service supports
     */
    readonly version: "v1";
    createProposal(agentContext: AgentContext, options: CreateProposalOptions<[IndyProofFormat]>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    createProposalAsResponse(agentContext: AgentContext, options: CreateProposalAsResponseOptions<[IndyProofFormat]>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    processProposal(messageContext: InboundMessageContext<V1ProposePresentationMessage>): Promise<ProofExchangeRecord>;
    createRequestAsResponse(agentContext: AgentContext, options: CreateRequestAsResponseOptions<[IndyProofFormat]>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    createRequest(agentContext: AgentContext, options: CreateRequestOptions<[IndyProofFormat]>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    processRequest(messageContext: InboundMessageContext<V1RequestPresentationMessage>): Promise<ProofExchangeRecord>;
    createPresentation(agentContext: AgentContext, options: CreatePresentationOptions<[IndyProofFormat]>): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    processPresentation(messageContext: InboundMessageContext<V1PresentationMessage>): Promise<ProofExchangeRecord>;
    processAck(messageContext: InboundMessageContext<V1PresentationAckMessage>): Promise<ProofExchangeRecord>;
    createProblemReport(agentContext: AgentContext, options: CreateProblemReportOptions): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
    processProblemReport(messageContext: InboundMessageContext<V1PresentationProblemReportMessage>): Promise<ProofExchangeRecord>;
    createProofRequestFromProposal(agentContext: AgentContext, options: CreateProofRequestFromProposalOptions): Promise<ProofRequestFromProposalOptions<ProofFormat[]>>;
    /**
     * Retrieves the linked attachments for an {@link indyProofRequest}
     * @param indyProofRequest The proof request for which the linked attachments have to be found
     * @param requestedCredentials The requested credentials
     * @returns a list of attachments that are linked to the requested credentials
     */
    getRequestedAttachmentsForRequestedCredentials(agentContext: AgentContext, indyProofRequest: ProofRequest, requestedCredentials: RequestedCredentials): Promise<Attachment[] | undefined>;
    shouldAutoRespondToProposal(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    shouldAutoRespondToRequest(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    shouldAutoRespondToPresentation(agentContext: AgentContext, proofRecord: ProofExchangeRecord): Promise<boolean>;
    getRequestedCredentialsForProofRequest(agentContext: AgentContext, options: GetRequestedCredentialsForProofRequestOptions): Promise<FormatRetrievedCredentialOptions<ProofFormat[]>>;
    autoSelectCredentialsForProofRequest(options: FormatRetrievedCredentialOptions<ProofFormat[]>): Promise<FormatRequestedCredentialReturn<ProofFormat[]>>;
    registerMessageHandlers(dispatcher: Dispatcher, agentConfig: AgentConfig, proofResponseCoordinator: ProofResponseCoordinator, mediationRecipientService: MediationRecipientService, routingService: RoutingService): void;
    findRequestMessage(agentContext: AgentContext, proofRecordId: string): Promise<V1RequestPresentationMessage | null>;
    findPresentationMessage(agentContext: AgentContext, proofRecordId: string): Promise<V1PresentationMessage | null>;
    findProposalMessage(agentContext: AgentContext, proofRecordId: string): Promise<V1ProposePresentationMessage | null>;
    getFormatData(agentContext: AgentContext, proofRecordId: string): Promise<GetFormatDataReturn<ProofFormat[]>>;
    private rfc0592ProposalFromV1ProposeMessage;
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    getAll(agentContext: AgentContext): Promise<ProofExchangeRecord[]>;
    /**
     * Retrieve a proof record by connection id and thread id
     *
     * @param connectionId The connection id
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The proof record
     */
    getByThreadAndConnectionId(agentContext: AgentContext, threadId: string, connectionId?: string): Promise<ProofExchangeRecord>;
    createAck(gentContext: AgentContext, options: CreateAckOptions): Promise<{
        proofRecord: ProofExchangeRecord;
        message: AgentMessage;
    }>;
}
