"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.V1ProofService = void 0;
const class_validator_1 = require("class-validator");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../../agent/EventEmitter");
const constants_1 = require("../../../../constants");
const AriesFrameworkError_1 = require("../../../../error/AriesFrameworkError");
const storage_1 = require("../../../../storage");
const DidCommMessageRepository_1 = require("../../../../storage/didcomm/DidCommMessageRepository");
const utils_1 = require("../../../../utils");
const JsonTransformer_1 = require("../../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const AckMessage_1 = require("../../../common/messages/AckMessage");
const connections_1 = require("../../../connections");
const credentials_1 = require("../../../credentials");
const IndyCredentialInfo_1 = require("../../../credentials/formats/indy/models/IndyCredentialInfo");
const indy_1 = require("../../../indy");
const IndyLedgerService_1 = require("../../../ledger/services/IndyLedgerService");
const ProofService_1 = require("../../ProofService");
const PresentationProblemReportReason_1 = require("../../errors/PresentationProblemReportReason");
const IndyProofFormatService_1 = require("../../formats/indy/IndyProofFormatService");
const ProofRequest_1 = require("../../formats/indy/models/ProofRequest");
const RequestedCredentials_1 = require("../../formats/indy/models/RequestedCredentials");
const ProofState_1 = require("../../models/ProofState");
const ProofExchangeRecord_1 = require("../../repository/ProofExchangeRecord");
const ProofRepository_1 = require("../../repository/ProofRepository");
const errors_1 = require("./errors");
const handlers_1 = require("./handlers");
const messages_1 = require("./messages");
const V1PresentationProblemReportMessage_1 = require("./messages/V1PresentationProblemReportMessage");
const V1PresentationPreview_1 = require("./models/V1PresentationPreview");
/**
 * @todo add method to check if request matches proposal. Useful to see if a request I received is the same as the proposal I sent.
 * @todo add method to reject / revoke messages
 * @todo validate attachments / messages
 */
let V1ProofService = class V1ProofService extends ProofService_1.ProofService {
    constructor(proofRepository, didCommMessageRepository, ledgerService, wallet, agentConfig, connectionService, eventEmitter, credentialRepository, formatService, indyHolderService, indyRevocationService) {
        super(agentConfig, proofRepository, connectionService, didCommMessageRepository, wallet, eventEmitter);
        /**
         * The version of the present proof protocol this service supports
         */
        this.version = 'v1';
        this.credentialRepository = credentialRepository;
        this.ledgerService = ledgerService;
        this.wallet = wallet;
        this.indyProofFormatService = formatService;
        this.indyHolderService = indyHolderService;
        this.indyRevocationService = indyRevocationService;
    }
    async createProposal(agentContext, options) {
        var _a, _b, _c;
        const { connectionRecord, proofFormats } = options;
        // Assert
        connectionRecord.assertReady();
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Only indy proof format is supported for present proof protocol v1');
        }
        const presentationProposal = new V1PresentationPreview_1.PresentationPreview({
            attributes: (_a = proofFormats.indy) === null || _a === void 0 ? void 0 : _a.attributes,
            predicates: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.predicates,
        });
        // Create message
        const proposalMessage = new messages_1.V1ProposePresentationMessage({
            comment: options === null || options === void 0 ? void 0 : options.comment,
            presentationProposal,
            parentThreadId: options.parentThreadId,
        });
        // Create record
        const proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
            connectionId: connectionRecord.id,
            threadId: proposalMessage.threadId,
            parentThreadId: (_c = proposalMessage.thread) === null || _c === void 0 ? void 0 : _c.parentThreadId,
            state: ProofState_1.ProofState.ProposalSent,
            autoAcceptProof: options === null || options === void 0 ? void 0 : options.autoAcceptProof,
            protocolVersion: 'v1',
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        await this.proofRepository.save(agentContext, proofRecord);
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return { proofRecord, message: proposalMessage };
    }
    async createProposalAsResponse(agentContext, options) {
        var _a, _b;
        const { proofRecord, proofFormats, comment } = options;
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Only indy proof format is supported for present proof protocol v1');
        }
        // Create message
        const presentationPreview = new V1PresentationPreview_1.PresentationPreview({
            attributes: (_a = proofFormats.indy) === null || _a === void 0 ? void 0 : _a.attributes,
            predicates: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.predicates,
        });
        const proposalMessage = new messages_1.V1ProposePresentationMessage({
            comment,
            presentationProposal: presentationPreview,
        });
        proposalMessage.setThread({ threadId: proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        // Update record
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.ProposalSent);
        return { proofRecord, message: proposalMessage };
    }
    async processProposal(messageContext) {
        var _a;
        let proofRecord;
        const { message: proposalMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation proposal with id ${proposalMessage.id}`);
        try {
            // Proof record already exists
            proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: messages_1.V1RequestPresentationMessage,
            });
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.RequestSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: proposalMessage,
                previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proposalMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Update record
            await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.ProposalReceived);
        }
        catch (_b) {
            // No proof record exists with thread id
            proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: proposalMessage.threadId,
                parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
                state: ProofState_1.ProofState.ProposalReceived,
                protocolVersion: 'v1',
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save record
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proposalMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Sender,
            });
            await this.proofRepository.save(messageContext.agentContext, proofRecord);
            this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
    }
    async createRequestAsResponse(agentContext, options) {
        const { proofRecord, comment, proofFormats } = options;
        if (!proofFormats.indy) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Only indy proof format is supported for present proof protocol v1');
        }
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.ProposalReceived);
        // Create message
        const { attachment } = await this.indyProofFormatService.createRequest({
            id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
            formats: proofFormats,
        });
        const requestPresentationMessage = new messages_1.V1RequestPresentationMessage({
            comment,
            requestPresentationAttachments: [attachment],
        });
        requestPresentationMessage.setThread({
            threadId: proofRecord.threadId,
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: requestPresentationMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        // Update record
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.RequestSent);
        return { message: requestPresentationMessage, proofRecord };
    }
    async createRequest(agentContext, options) {
        var _a, _b;
        this.logger.debug(`Creating proof request`);
        // Assert
        if (options.connectionRecord) {
            options.connectionRecord.assertReady();
        }
        if (!options.proofFormats.indy || Object.keys(options.proofFormats).length !== 1) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Only indy proof format is supported for present proof protocol v1');
        }
        // Create message
        const { attachment } = await this.indyProofFormatService.createRequest({
            id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
            formats: options.proofFormats,
        });
        const requestPresentationMessage = new messages_1.V1RequestPresentationMessage({
            comment: options === null || options === void 0 ? void 0 : options.comment,
            requestPresentationAttachments: [attachment],
            parentThreadId: options.parentThreadId,
        });
        // Create record
        const proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
            connectionId: (_a = options.connectionRecord) === null || _a === void 0 ? void 0 : _a.id,
            threadId: requestPresentationMessage.threadId,
            parentThreadId: (_b = requestPresentationMessage.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId,
            state: ProofState_1.ProofState.RequestSent,
            autoAcceptProof: options === null || options === void 0 ? void 0 : options.autoAcceptProof,
            protocolVersion: 'v1',
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: requestPresentationMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        await this.proofRepository.save(agentContext, proofRecord);
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return { message: requestPresentationMessage, proofRecord };
    }
    async processRequest(messageContext) {
        var _a;
        let proofRecord;
        const { message: proofRequestMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation request with id ${proofRequestMessage.id}`);
        const requestAttachments = proofRequestMessage.getAttachmentFormats();
        for (const attachmentFormat of requestAttachments) {
            await this.indyProofFormatService.processRequest({
                requestAttachment: attachmentFormat,
            });
        }
        const proofRequest = proofRequestMessage.indyProofRequest;
        // Assert attachment
        if (!proofRequest) {
            throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${proofRequestMessage.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        this.logger.debug('received proof request', proofRequest);
        try {
            // Proof record already exists
            proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, proofRequestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: messages_1.V1RequestPresentationMessage,
            });
            const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
                associatedRecordId: proofRecord.id,
                messageClass: messages_1.V1ProposePresentationMessage,
            });
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.ProposalSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
                previousSentMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : undefined,
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proofRequestMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Update record
            await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.RequestReceived);
        }
        catch (_b) {
            // No proof record exists with thread id
            proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: proofRequestMessage.threadId,
                parentThreadId: (_a = proofRequestMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
                state: ProofState_1.ProofState.RequestReceived,
                protocolVersion: 'v1',
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: proofRequestMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save in repository
            await this.proofRepository.save(messageContext.agentContext, proofRecord);
            this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
    }
    async createPresentation(agentContext, options) {
        var _a, _b, _c, _d;
        const { proofRecord, proofFormats } = options;
        this.logger.debug(`Creating presentation for proof record with id ${proofRecord.id}`);
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Only indy proof format is supported for present proof protocol v1');
        }
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        const requestAttachment = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyAttachment;
        if (!requestAttachment) {
            throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation with thread id ${proofRecord.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        const presentationOptions = {
            id: messages_1.INDY_PROOF_ATTACHMENT_ID,
            attachment: requestAttachment,
            proofFormats: proofFormats,
        };
        const proof = await this.indyProofFormatService.createPresentation(agentContext, presentationOptions);
        // Extract proof request from attachment
        const proofRequestJson = (_a = requestAttachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
            requestedAttributes: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.requestedAttributes,
            requestedPredicates: (_c = proofFormats.indy) === null || _c === void 0 ? void 0 : _c.requestedPredicates,
            selfAttestedAttributes: (_d = proofFormats.indy) === null || _d === void 0 ? void 0 : _d.selfAttestedAttributes,
        });
        // Get the matching attachments to the requested credentials
        const linkedAttachments = await this.getRequestedAttachmentsForRequestedCredentials(agentContext, proofRequest, requestedCredentials);
        const presentationMessage = new messages_1.V1PresentationMessage({
            comment: options === null || options === void 0 ? void 0 : options.comment,
            presentationAttachments: [proof.attachment],
            attachments: linkedAttachments,
        });
        presentationMessage.setThread({ threadId: proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
            agentMessage: presentationMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender,
        });
        // Update record
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.PresentationSent);
        return { message: presentationMessage, proofRecord };
    }
    async processPresentation(messageContext) {
        const { message: presentationMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : undefined,
            previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
        });
        try {
            const isValid = await this.indyProofFormatService.processPresentation(messageContext.agentContext, {
                record: proofRecord,
                formatAttachments: {
                    presentation: presentationMessage.getAttachmentFormats(),
                    request: requestMessage.getAttachmentFormats(),
                },
            });
            await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
                agentMessage: presentationMessage,
                associatedRecordId: proofRecord.id,
                role: storage_1.DidCommMessageRole.Receiver,
            });
            // Update record
            proofRecord.isVerified = isValid;
            await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.PresentationReceived);
        }
        catch (e) {
            if (e instanceof AriesFrameworkError_1.AriesFrameworkError) {
                throw new errors_1.V1PresentationProblemReportError(e.message, {
                    problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
                });
            }
            throw e;
        }
        return proofRecord;
    }
    async processAck(messageContext) {
        const { message: presentationAckMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation ack with id ${presentationAckMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationAckMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1PresentationMessage,
        });
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.PresentationSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : undefined,
            previousSentMessage: presentationMessage !== null && presentationMessage !== void 0 ? presentationMessage : undefined,
        });
        // Update record
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Done);
        return proofRecord;
    }
    async createProblemReport(agentContext, options) {
        const msg = new V1PresentationProblemReportMessage_1.V1PresentationProblemReportMessage({
            description: {
                code: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
                en: options.description,
            },
        });
        msg.setThread({
            threadId: options.proofRecord.threadId,
            parentThreadId: options.proofRecord.parentThreadId,
        });
        return {
            proofRecord: options.proofRecord,
            message: msg,
        };
    }
    async processProblemReport(messageContext) {
        const { message: presentationProblemReportMessage } = messageContext;
        const connection = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${presentationProblemReportMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationProblemReportMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        proofRecord.errorMessage = `${presentationProblemReportMessage.description.code}: ${presentationProblemReportMessage.description.en}`;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Abandoned);
        return proofRecord;
    }
    async createProofRequestFromProposal(agentContext, options) {
        const proofRecordId = options.proofRecord.id;
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
        if (!proposalMessage) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Proof record with id ${proofRecordId} is missing required presentation proposal`);
        }
        const indyProposeProofFormat = {
            name: 'Proof Request',
            version: '1.0',
            nonce: await this.wallet.generateNonce(),
        };
        const proofRequest = await this.indyProofFormatService.createReferentForProofRequest(indyProposeProofFormat, proposalMessage.presentationProposal);
        return {
            proofRecord: options.proofRecord,
            proofFormats: {
                indy: proofRequest,
            },
        };
    }
    /**
     * Retrieves the linked attachments for an {@link indyProofRequest}
     * @param indyProofRequest The proof request for which the linked attachments have to be found
     * @param requestedCredentials The requested credentials
     * @returns a list of attachments that are linked to the requested credentials
     */
    async getRequestedAttachmentsForRequestedCredentials(agentContext, indyProofRequest, requestedCredentials) {
        var _a, _b;
        const attachments = [];
        const credentialIds = new Set();
        const requestedAttributesNames = [];
        // Get the credentialIds if it contains a hashlink
        for (const [referent, requestedAttribute] of Object.entries(requestedCredentials.requestedAttributes)) {
            // Find the requested Attributes
            const requestedAttributes = indyProofRequest.requestedAttributes.get(referent);
            // List the requested attributes
            requestedAttributesNames.push(...((_a = requestedAttributes.names) !== null && _a !== void 0 ? _a : [requestedAttributes.name]));
            //Get credentialInfo
            if (!requestedAttribute.credentialInfo) {
                const indyCredentialInfo = await this.indyHolderService.getCredential(agentContext, requestedAttribute.credentialId);
                requestedAttribute.credentialInfo = JsonTransformer_1.JsonTransformer.fromJSON(indyCredentialInfo, IndyCredentialInfo_1.IndyCredentialInfo);
            }
            // Find the attributes that have a hashlink as a value
            for (const attribute of Object.values(requestedAttribute.credentialInfo.attributes)) {
                if (attribute.toLowerCase().startsWith('hl:')) {
                    credentialIds.add(requestedAttribute.credentialId);
                }
            }
        }
        // Only continues if there is an attribute value that contains a hashlink
        for (const credentialId of credentialIds) {
            // Get the credentialRecord that matches the ID
            const credentialRecord = await this.credentialRepository.getSingleByQuery(agentContext, {
                credentialIds: [credentialId],
            });
            if (credentialRecord.linkedAttachments) {
                // Get the credentials that have a hashlink as value and are requested
                const requestedCredentials = (_b = credentialRecord.credentialAttributes) === null || _b === void 0 ? void 0 : _b.filter((credential) => credential.value.toLowerCase().startsWith('hl:') && requestedAttributesNames.includes(credential.name));
                // Get the linked attachments that match the requestedCredentials
                const linkedAttachments = credentialRecord.linkedAttachments.filter((attachment) => requestedCredentials === null || requestedCredentials === void 0 ? void 0 : requestedCredentials.map((credential) => credential.value.split(':')[1]).includes(attachment.id));
                if (linkedAttachments) {
                    attachments.push(...linkedAttachments);
                }
            }
        }
        return attachments.length ? attachments : undefined;
    }
    async shouldAutoRespondToProposal(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
        if (!proposal)
            return false;
        MessageValidator_1.MessageValidator.validateSync(proposal);
        // check the proposal against a possible previous request
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        if (!request)
            return false;
        const proofRequest = request.indyProofRequest;
        if (!proofRequest) {
            throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${request.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        const proposalAttributes = proposal.presentationProposal.attributes;
        const requestedAttributes = proofRequest.requestedAttributes;
        const proposedAttributeNames = proposalAttributes.map((x) => x.name);
        let requestedAttributeNames = [];
        const requestedAttributeList = Array.from(requestedAttributes.values());
        requestedAttributeList.forEach((x) => {
            if (x.name) {
                requestedAttributeNames.push(x.name);
            }
            else if (x.names) {
                requestedAttributeNames = requestedAttributeNames.concat(x.names);
            }
        });
        if (requestedAttributeNames.length > proposedAttributeNames.length) {
            // more attributes are requested than have been proposed
            return false;
        }
        requestedAttributeNames.forEach((x) => {
            if (!proposedAttributeNames.includes(x)) {
                this.logger.debug(`Attribute ${x} was requested but wasn't proposed.`);
                return false;
            }
        });
        // assert that all requested attributes are provided
        const providedPredicateNames = proposal.presentationProposal.predicates.map((x) => x.name);
        proofRequest.requestedPredicates.forEach((x) => {
            if (!providedPredicateNames.includes(x.name)) {
                return false;
            }
        });
        return true;
    }
    async shouldAutoRespondToRequest(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
        if (!proposal) {
            return false;
        }
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        if (!request) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Expected to find a request message for ProofExchangeRecord with id ${proofRecord.id}`);
        }
        const proofRequest = request.indyProofRequest;
        // Assert attachment
        if (!proofRequest) {
            throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${request.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        const proposalAttributes = proposal.presentationProposal.attributes;
        const requestedAttributes = proofRequest.requestedAttributes;
        const proposedAttributeNames = proposalAttributes.map((x) => x.name);
        let requestedAttributeNames = [];
        const requestedAttributeList = Array.from(requestedAttributes.values());
        requestedAttributeList.forEach((x) => {
            if (x.name) {
                requestedAttributeNames.push(x.name);
            }
            else if (x.names) {
                requestedAttributeNames = requestedAttributeNames.concat(x.names);
            }
        });
        if (requestedAttributeNames.length > proposedAttributeNames.length) {
            // more attributes are requested than have been proposed
            return false;
        }
        requestedAttributeNames.forEach((x) => {
            if (!proposedAttributeNames.includes(x)) {
                this.logger.debug(`Attribute ${x} was requested but wasn't proposed.`);
                return false;
            }
        });
        // assert that all requested attributes are provided
        const providedPredicateNames = proposal.presentationProposal.predicates.map((x) => x.name);
        proofRequest.requestedPredicates.forEach((x) => {
            if (!providedPredicateNames.includes(x.name)) {
                return false;
            }
        });
        return true;
    }
    async shouldAutoRespondToPresentation(agentContext, proofRecord) {
        this.logger.debug(`Should auto respond to presentation for proof record id: ${proofRecord.id}`);
        return true;
    }
    async getRequestedCredentialsForProofRequest(agentContext, options) {
        var _a;
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: options.proofRecord.id,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
        const indyProofRequest = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.requestPresentationAttachments;
        if (!indyProofRequest) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Could not find proof request');
        }
        const requestedCredentials = await this.indyProofFormatService.getRequestedCredentialsForProofRequest(agentContext, {
            attachment: indyProofRequest[0],
            presentationProposal: proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.presentationProposal,
            config: (_a = options.config) !== null && _a !== void 0 ? _a : undefined,
        });
        return requestedCredentials;
    }
    async autoSelectCredentialsForProofRequest(options) {
        return await this.indyProofFormatService.autoSelectCredentialsForProofRequest(options);
    }
    registerMessageHandlers(dispatcher, agentConfig, proofResponseCoordinator, mediationRecipientService, routingService) {
        dispatcher.registerMessageHandler(new handlers_1.V1ProposePresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new handlers_1.V1RequestPresentationHandler(this, agentConfig, proofResponseCoordinator, mediationRecipientService, this.didCommMessageRepository, routingService));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationAckHandler(this));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationProblemReportHandler(this));
    }
    async findRequestMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: messages_1.V1RequestPresentationMessage,
        });
    }
    async findPresentationMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: messages_1.V1PresentationMessage,
        });
    }
    async findProposalMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
            associatedRecordId: proofRecordId,
            messageClass: messages_1.V1ProposePresentationMessage,
        });
    }
    async getFormatData(agentContext, proofRecordId) {
        var _a, _b;
        const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([
            this.findProposalMessage(agentContext, proofRecordId),
            this.findRequestMessage(agentContext, proofRecordId),
            this.findPresentationMessage(agentContext, proofRecordId),
        ]);
        const indyProposeProof = proposalMessage
            ? JsonTransformer_1.JsonTransformer.toJSON(await this.rfc0592ProposalFromV1ProposeMessage(proposalMessage))
            : undefined;
        const indyRequestProof = (_a = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyProofRequestJson) !== null && _a !== void 0 ? _a : undefined;
        const indyPresentProof = (_b = presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.indyProof) !== null && _b !== void 0 ? _b : undefined;
        return {
            proposal: proposalMessage
                ? {
                    indy: indyProposeProof,
                }
                : undefined,
            request: requestMessage
                ? {
                    indy: indyRequestProof,
                }
                : undefined,
            presentation: presentationMessage
                ? {
                    indy: indyPresentProof,
                }
                : undefined,
        };
    }
    async rfc0592ProposalFromV1ProposeMessage(proposalMessage) {
        const indyFormat = {
            name: 'Proof Request',
            version: '1.0',
            nonce: await this.wallet.generateNonce(),
            attributes: proposalMessage.presentationProposal.attributes,
            predicates: proposalMessage.presentationProposal.predicates,
        };
        if (!indyFormat) {
            throw new AriesFrameworkError_1.AriesFrameworkError('No Indy format found.');
        }
        const preview = new V1PresentationPreview_1.PresentationPreview({
            attributes: indyFormat.attributes,
            predicates: indyFormat.predicates,
        });
        return this.indyProofFormatService.createReferentForProofRequest(indyFormat, preview);
    }
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    async getAll(agentContext) {
        return this.proofRepository.getAll(agentContext);
    }
    /**
     * Retrieve a proof record by connection id and thread id
     *
     * @param connectionId The connection id
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The proof record
     */
    async getByThreadAndConnectionId(agentContext, threadId, connectionId) {
        return this.proofRepository.getSingleByQuery(agentContext, { threadId, connectionId });
    }
    async createAck(gentContext, options) {
        const { proofRecord } = options;
        this.logger.debug(`Creating presentation ack for proof record with id ${proofRecord.id}`);
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.PresentationReceived);
        // Create message
        const ackMessage = new messages_1.V1PresentationAckMessage({
            status: AckMessage_1.AckStatus.OK,
            threadId: proofRecord.threadId,
        });
        // Update record
        await this.updateState(gentContext, proofRecord, ProofState_1.ProofState.Done);
        return { message: ackMessage, proofRecord };
    }
};
V1ProofService = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __param(3, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [ProofRepository_1.ProofRepository,
        DidCommMessageRepository_1.DidCommMessageRepository,
        IndyLedgerService_1.IndyLedgerService, Object, AgentConfig_1.AgentConfig,
        connections_1.ConnectionService,
        EventEmitter_1.EventEmitter,
        credentials_1.CredentialRepository,
        IndyProofFormatService_1.IndyProofFormatService,
        indy_1.IndyHolderService,
        indy_1.IndyRevocationService])
], V1ProofService);
exports.V1ProofService = V1ProofService;
//# sourceMappingURL=V1ProofService.js.map