"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyProofFormatService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../../agent/AgentConfig");
const Attachment_1 = require("../../../../decorators/attachment/Attachment");
const AriesFrameworkError_1 = require("../../../../error/AriesFrameworkError");
const logger_1 = require("../../../../logger");
const DidCommMessageRepository_1 = require("../../../../storage/didcomm/DidCommMessageRepository");
const utils_1 = require("../../../../utils");
const JsonEncoder_1 = require("../../../../utils/JsonEncoder");
const JsonTransformer_1 = require("../../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const uuid_1 = require("../../../../utils/uuid");
const IndyWallet_1 = require("../../../../wallet/IndyWallet");
const credentials_1 = require("../../../credentials");
const IndyCredentialUtils_1 = require("../../../credentials/formats/indy/IndyCredentialUtils");
const indy_1 = require("../../../indy");
const ledger_1 = require("../../../ledger");
const ProofFormatSpec_1 = require("../../models/ProofFormatSpec");
const models_1 = require("../../protocol/v1/models");
const ProofFormatConstants_1 = require("../ProofFormatConstants");
const ProofFormatService_1 = require("../ProofFormatService");
const InvalidEncodedValueError_1 = require("./errors/InvalidEncodedValueError");
const MissingIndyProofMessageError_1 = require("./errors/MissingIndyProofMessageError");
const models_2 = require("./models");
const ProofRequest_1 = require("./models/ProofRequest");
const RequestedCredentials_1 = require("./models/RequestedCredentials");
const RetrievedCredentials_1 = require("./models/RetrievedCredentials");
let IndyProofFormatService = class IndyProofFormatService extends ProofFormatService_1.ProofFormatService {
    constructor(agentConfig, indyHolderService, indyVerifierService, indyRevocationService, ledgerService, didCommMessageRepository, wallet) {
        super(didCommMessageRepository, agentConfig);
        this.formatKey = 'indy';
        this.proofRecordType = 'indy';
        this.indyHolderService = indyHolderService;
        this.indyVerifierService = indyVerifierService;
        this.indyRevocationService = indyRevocationService;
        this.ledgerService = ledgerService;
        this.wallet = wallet;
        this.logger = new logger_1.ConsoleLogger(logger_1.LogLevel.off);
    }
    createRequestAttachment(options) {
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            attachmentId: options.id,
            format: ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST,
        });
        const request = new ProofRequest_1.ProofRequest(options.proofRequestOptions);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(request);
        const attachment = new Attachment_1.Attachment({
            id: options.id,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(request),
            }),
        });
        return { format, attachment };
    }
    async createProofAttachment(options) {
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            attachmentId: options.id,
            format: ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL,
        });
        const request = new ProofRequest_1.ProofRequest(options.proofProposalOptions);
        MessageValidator_1.MessageValidator.validateSync(request);
        const attachment = new Attachment_1.Attachment({
            id: options.id,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(JsonTransformer_1.JsonTransformer.toJSON(request)),
            }),
        });
        return { format, attachment };
    }
    async createProposal(options) {
        var _a;
        if (!options.formats.indy) {
            throw Error('Missing indy format to create proposal attachment format');
        }
        const proofRequest = await this.createRequestFromPreview(options.formats.indy);
        return await this.createProofAttachment({
            id: (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)(),
            proofProposalOptions: proofRequest,
        });
    }
    async processProposal(options) {
        var _a;
        const proofProposalJson = options.proposal.attachment.getDataAsJson();
        // Assert attachment
        if (!proofProposalJson) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation proposal with thread id ${(_a = options.record) === null || _a === void 0 ? void 0 : _a.threadId}`);
        }
        const proposalMessage = JsonTransformer_1.JsonTransformer.fromJSON(proofProposalJson, ProofRequest_1.ProofRequest);
        MessageValidator_1.MessageValidator.validateSync(proposalMessage);
    }
    async createRequestAsResponse(options) {
        var _a;
        if (!options.proofFormats.indy) {
            throw Error('Missing indy format to create proposal attachment format');
        }
        const id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            attachmentId: id,
            format: ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST,
        });
        const attachment = new Attachment_1.Attachment({
            id: id,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(options.proofFormats.indy),
            }),
        });
        return { format, attachment };
    }
    async createRequest(options) {
        var _a, _b, _c, _d;
        if (!options.formats.indy) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Missing indy format to create proof request attachment format.');
        }
        const indyFormat = options.formats.indy;
        return this.createRequestAttachment({
            id: (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)(),
            proofRequestOptions: Object.assign(Object.assign({}, indyFormat), { name: (_b = indyFormat.name) !== null && _b !== void 0 ? _b : 'proof-request', version: (_c = indyFormat.version) !== null && _c !== void 0 ? _c : '1.0', nonce: (_d = indyFormat.nonce) !== null && _d !== void 0 ? _d : (await this.wallet.generateNonce()) }),
        });
    }
    async processRequest(options) {
        var _a;
        const proofRequestJson = options.requestAttachment.attachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        // Assert attachment
        if (!proofRequest) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${(_a = options.record) === null || _a === void 0 ? void 0 : _a.threadId}`);
        }
        MessageValidator_1.MessageValidator.validateSync(proofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
    }
    async createPresentation(agentContext, options) {
        var _a, _b;
        // Extract proof request from attachment
        const proofRequestJson = (_a = options.attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        // verify everything is there
        if (!options.proofFormats.indy) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Missing indy format to create proof presentation attachment format.');
        }
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
            requestedAttributes: options.proofFormats.indy.requestedAttributes,
            requestedPredicates: options.proofFormats.indy.requestedPredicates,
            selfAttestedAttributes: options.proofFormats.indy.selfAttestedAttributes,
        });
        const proof = await this.createProof(agentContext, proofRequest, requestedCredentials);
        const attachmentId = (_b = options.id) !== null && _b !== void 0 ? _b : (0, uuid_1.uuid)();
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            attachmentId,
            format: ProofFormatConstants_1.V2_INDY_PRESENTATION,
        });
        const attachment = new Attachment_1.Attachment({
            id: attachmentId,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(proof),
            }),
        });
        return { format, attachment };
    }
    async processPresentation(agentContext, options) {
        const requestFormat = options.formatAttachments.request.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST);
        if (!requestFormat) {
            throw new MissingIndyProofMessageError_1.MissingIndyProofMessageError('Missing Indy Proof Request format while trying to process an Indy proof presentation.');
        }
        const proofFormat = options.formatAttachments.presentation.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION);
        if (!proofFormat) {
            throw new MissingIndyProofMessageError_1.MissingIndyProofMessageError('Missing Indy Proof Presentation format while trying to process an Indy proof presentation.');
        }
        return await this.verifyProof(agentContext, { request: requestFormat.attachment, proof: proofFormat.attachment });
    }
    async verifyProof(agentContext, options) {
        var _a, _b;
        if (!options) {
            throw new AriesFrameworkError_1.AriesFrameworkError('No Indy proof was provided.');
        }
        const proofRequestJson = (_a = options.request.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        const proofJson = (_b = options.proof.getDataAsJson()) !== null && _b !== void 0 ? _b : null;
        const proof = JsonTransformer_1.JsonTransformer.fromJSON(proofJson, models_1.PartialProof);
        for (const [referent, attribute] of proof.requestedProof.revealedAttributes.entries()) {
            if (!IndyCredentialUtils_1.IndyCredentialUtils.checkValidEncoding(attribute.raw, attribute.encoded)) {
                throw new InvalidEncodedValueError_1.InvalidEncodedValueError(`The encoded value for '${referent}' is invalid. ` +
                    `Expected '${IndyCredentialUtils_1.IndyCredentialUtils.encode(attribute.raw)}'. ` +
                    `Actual '${attribute.encoded}'`);
            }
        }
        // TODO: pre verify proof json
        // I'm not 100% sure how much indy does. Also if it checks whether the proof requests matches the proof
        // @see https://github.com/hyperledger/aries-cloudagent-python/blob/master/aries_cloudagent/indy/sdk/verifier.py#L79-L164
        const schemas = await this.getSchemas(agentContext, new Set(proof.identifiers.map((i) => i.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(proof.identifiers.map((i) => i.credentialDefinitionId)));
        return await this.indyVerifierService.verifyProof(agentContext, {
            proofRequest: proofRequest.toJSON(),
            proof: proofJson,
            schemas,
            credentialDefinitions,
        });
    }
    supportsFormat(formatIdentifier) {
        const supportedFormats = [ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL, ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST, ProofFormatConstants_1.V2_INDY_PRESENTATION];
        return supportedFormats.includes(formatIdentifier);
    }
    /**
     * Compare presentation attrs with request/proposal attrs (auto-accept)
     *
     * @param proposalAttachments attachment data from the proposal
     * @param requestAttachments  attachment data from the request
     * @returns boolean value
     */
    proposalAndRequestAreEqual(proposalAttachments, requestAttachments) {
        var _a, _b;
        const proposalAttachment = (_a = proposalAttachments.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL)) === null || _a === void 0 ? void 0 : _a.attachment;
        const requestAttachment = (_b = requestAttachments.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST)) === null || _b === void 0 ? void 0 : _b.attachment;
        if (!proposalAttachment) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Proposal message has no attachment linked to it');
        }
        if (!requestAttachment) {
            throw new AriesFrameworkError_1.AriesFrameworkError('Request message has no attachment linked to it');
        }
        const proposalAttachmentJson = proposalAttachment.getDataAsJson();
        const proposalAttachmentData = JsonTransformer_1.JsonTransformer.fromJSON(proposalAttachmentJson, ProofRequest_1.ProofRequest);
        const requestAttachmentJson = requestAttachment.getDataAsJson();
        const requestAttachmentData = JsonTransformer_1.JsonTransformer.fromJSON(requestAttachmentJson, ProofRequest_1.ProofRequest);
        if ((0, utils_1.deepEquality)(proposalAttachmentData.requestedAttributes, requestAttachmentData.requestedAttributes) &&
            (0, utils_1.deepEquality)(proposalAttachmentData.requestedPredicates, requestAttachmentData.requestedPredicates)) {
            return true;
        }
        return false;
    }
    /**
     * Build credential definitions object needed to create and verify proof objects.
     *
     * Creates object with `{ credentialDefinitionId: CredentialDefinition }` mapping
     *
     * @param credentialDefinitionIds List of credential definition ids
     * @returns Object containing credential definitions for specified credential definition ids
     *
     */
    async getCredentialDefinitions(agentContext, credentialDefinitionIds) {
        const credentialDefinitions = {};
        for (const credDefId of credentialDefinitionIds) {
            const credDef = await this.ledgerService.getCredentialDefinition(agentContext, credDefId);
            credentialDefinitions[credDefId] = credDef;
        }
        return credentialDefinitions;
    }
    async getRequestedCredentialsForProofRequest(agentContext, options) {
        var _a, _b, _c;
        const retrievedCredentials = new RetrievedCredentials_1.RetrievedCredentials({});
        const { attachment, presentationProposal } = options;
        const filterByNonRevocationRequirements = (_a = options.config) === null || _a === void 0 ? void 0 : _a.filterByNonRevocationRequirements;
        const proofRequestJson = (_b = attachment.getDataAsJson()) !== null && _b !== void 0 ? _b : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        for (const [referent, requestedAttribute] of proofRequest.requestedAttributes.entries()) {
            let credentialMatch = [];
            const credentials = await this.getCredentialsForProofRequest(agentContext, proofRequest, referent);
            // If we have exactly one credential, or no proposal to pick preferences
            // on the credentials to use, we will use the first one
            if (credentials.length === 1 || !presentationProposal) {
                credentialMatch = credentials;
            }
            // If we have a proposal we will use that to determine the credentials to use
            else {
                const names = (_c = requestedAttribute.names) !== null && _c !== void 0 ? _c : [requestedAttribute.name];
                // Find credentials that matches all parameters from the proposal
                credentialMatch = credentials.filter((credential) => {
                    const { attributes, credentialDefinitionId } = credential.credentialInfo;
                    // Check if credentials matches all parameters from proposal
                    return names.every((name) => presentationProposal.attributes.find((a) => a.name === name &&
                        a.credentialDefinitionId === credentialDefinitionId &&
                        (!a.value || a.value === attributes[name])));
                });
            }
            retrievedCredentials.requestedAttributes[referent] = await Promise.all(credentialMatch.map(async (credential) => {
                const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
                    proofRequest,
                    requestedItem: requestedAttribute,
                    credential,
                });
                return new models_2.RequestedAttribute({
                    credentialId: credential.credentialInfo.referent,
                    revealed: true,
                    credentialInfo: credential.credentialInfo,
                    timestamp: deltaTimestamp,
                    revoked,
                });
            }));
            // We only attach revoked state if non-revocation is requested. So if revoked is true it means
            // the credential is not applicable to the proof request
            if (filterByNonRevocationRequirements) {
                retrievedCredentials.requestedAttributes[referent] = retrievedCredentials.requestedAttributes[referent].filter((r) => !r.revoked);
            }
        }
        for (const [referent, requestedPredicate] of proofRequest.requestedPredicates.entries()) {
            const credentials = await this.getCredentialsForProofRequest(agentContext, proofRequest, referent);
            retrievedCredentials.requestedPredicates[referent] = await Promise.all(credentials.map(async (credential) => {
                const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
                    proofRequest,
                    requestedItem: requestedPredicate,
                    credential,
                });
                return new models_2.RequestedPredicate({
                    credentialId: credential.credentialInfo.referent,
                    credentialInfo: credential.credentialInfo,
                    timestamp: deltaTimestamp,
                    revoked,
                });
            }));
            // We only attach revoked state if non-revocation is requested. So if revoked is true it means
            // the credential is not applicable to the proof request
            if (filterByNonRevocationRequirements) {
                retrievedCredentials.requestedPredicates[referent] = retrievedCredentials.requestedPredicates[referent].filter((r) => !r.revoked);
            }
        }
        return {
            proofFormats: {
                indy: retrievedCredentials,
            },
        };
    }
    async getCredentialsForProofRequest(agentContext, proofRequest, attributeReferent) {
        const credentialsJson = await this.indyHolderService.getCredentialsForProofRequest(agentContext, {
            proofRequest: proofRequest.toJSON(),
            attributeReferent,
        });
        return JsonTransformer_1.JsonTransformer.fromJSON(credentialsJson, credentials_1.IndyCredential);
    }
    async autoSelectCredentialsForProofRequest(options) {
        const { proofFormats } = options;
        const indy = proofFormats.indy;
        if (!indy) {
            throw new AriesFrameworkError_1.AriesFrameworkError('No indy options provided');
        }
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({});
        Object.keys(indy.requestedAttributes).forEach((attributeName) => {
            const attributeArray = indy.requestedAttributes[attributeName];
            if (attributeArray.length === 0) {
                throw new AriesFrameworkError_1.AriesFrameworkError('Unable to automatically select requested attributes.');
            }
            else {
                requestedCredentials.requestedAttributes[attributeName] = attributeArray[0];
            }
        });
        Object.keys(indy.requestedPredicates).forEach((attributeName) => {
            if (indy.requestedPredicates[attributeName].length === 0) {
                throw new AriesFrameworkError_1.AriesFrameworkError('Unable to automatically select requested predicates.');
            }
            else {
                requestedCredentials.requestedPredicates[attributeName] = indy.requestedPredicates[attributeName][0];
            }
        });
        return {
            proofFormats: {
                indy: requestedCredentials,
            },
        };
    }
    /**
     * Build schemas object needed to create and verify proof objects.
     *
     * Creates object with `{ schemaId: Schema }` mapping
     *
     * @param schemaIds List of schema ids
     * @returns Object containing schemas for specified schema ids
     *
     */
    async getSchemas(agentContext, schemaIds) {
        const schemas = {};
        for (const schemaId of schemaIds) {
            const schema = await this.ledgerService.getSchema(agentContext, schemaId);
            schemas[schemaId] = schema;
        }
        return schemas;
    }
    /**
     * Create indy proof from a given proof request and requested credential object.
     *
     * @param proofRequest The proof request to create the proof for
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @returns indy proof object
     */
    async createProof(agentContext, proofRequest, requestedCredentials) {
        const credentialObjects = await Promise.all([
            ...Object.values(requestedCredentials.requestedAttributes),
            ...Object.values(requestedCredentials.requestedPredicates),
        ].map(async (c) => {
            if (c.credentialInfo) {
                return c.credentialInfo;
            }
            const credentialInfo = await this.indyHolderService.getCredential(agentContext, c.credentialId);
            return JsonTransformer_1.JsonTransformer.fromJSON(credentialInfo, credentials_1.IndyCredentialInfo);
        }));
        const schemas = await this.getSchemas(agentContext, new Set(credentialObjects.map((c) => c.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(credentialObjects.map((c) => c.credentialDefinitionId)));
        return await this.indyHolderService.createProof(agentContext, {
            proofRequest: proofRequest.toJSON(),
            requestedCredentials: requestedCredentials,
            schemas,
            credentialDefinitions,
        });
    }
    async createProofRequestFromProposal(options) {
        const proofRequestJson = options.presentationAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        // Assert attachment
        if (!proofRequest) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation request.`);
        }
        MessageValidator_1.MessageValidator.validateSync(proofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        return {
            indy: proofRequest,
        };
    }
    async getRevocationStatusForRequestedItem(agentContext, { proofRequest, requestedItem, credential, }) {
        var _a;
        const requestNonRevoked = (_a = requestedItem.nonRevoked) !== null && _a !== void 0 ? _a : proofRequest.nonRevoked;
        const credentialRevocationId = credential.credentialInfo.credentialRevocationId;
        const revocationRegistryId = credential.credentialInfo.revocationRegistryId;
        // If revocation interval is present and the credential is revocable then fetch the revocation status of credentials for display
        if (requestNonRevoked && credentialRevocationId && revocationRegistryId) {
            this.logger.trace(`Presentation is requesting proof of non revocation, getting revocation status for credential`, {
                requestNonRevoked,
                credentialRevocationId,
                revocationRegistryId,
            });
            // Note presentation from-to's vs ledger from-to's: https://github.com/hyperledger/indy-hipe/blob/master/text/0011-cred-revocation/README.md#indy-node-revocation-registry-intervals
            const status = await this.indyRevocationService.getRevocationStatus(agentContext, credentialRevocationId, revocationRegistryId, requestNonRevoked);
            return status;
        }
        return { revoked: undefined, deltaTimestamp: undefined };
    }
    async createRequestFromPreview(indyFormat) {
        const preview = new models_1.PresentationPreview({
            attributes: indyFormat.attributes,
            predicates: indyFormat.predicates,
        });
        const proofRequest = await this.createReferentForProofRequest(indyFormat, preview);
        return proofRequest;
    }
    async createReferentForProofRequest(indyFormat, preview) {
        var _a, _b, _c;
        const proofRequest = new ProofRequest_1.ProofRequest({
            name: (_a = indyFormat.name) !== null && _a !== void 0 ? _a : 'proof-request',
            version: (_b = indyFormat.version) !== null && _b !== void 0 ? _b : '1.0',
            nonce: (_c = indyFormat.nonce) !== null && _c !== void 0 ? _c : (await this.wallet.generateNonce()),
        });
        /**
         * Create mapping of attributes by referent. This required the
         * attributes to come from the same credential.
         * @see https://github.com/hyperledger/aries-rfcs/blob/master/features/0037-present-proof/README.md#referent
         *
         * {
         *  "referent1": [Attribute1, Attribute2],
         *  "referent2": [Attribute3]
         * }
         */
        const attributesByReferent = {};
        for (const proposedAttributes of preview.attributes) {
            if (!proposedAttributes.referent)
                proposedAttributes.referent = (0, uuid_1.uuid)();
            const referentAttributes = attributesByReferent[proposedAttributes.referent];
            // Referent key already exist, add to list
            if (referentAttributes) {
                referentAttributes.push(proposedAttributes);
            }
            // Referent key does not exist yet, create new entry
            else {
                attributesByReferent[proposedAttributes.referent] = [proposedAttributes];
            }
        }
        // Transform attributes by referent to requested attributes
        for (const [referent, proposedAttributes] of Object.entries(attributesByReferent)) {
            // Either attributeName or attributeNames will be undefined
            const attributeName = proposedAttributes.length == 1 ? proposedAttributes[0].name : undefined;
            const attributeNames = proposedAttributes.length > 1 ? proposedAttributes.map((a) => a.name) : undefined;
            const requestedAttribute = new models_2.ProofAttributeInfo({
                name: attributeName,
                names: attributeNames,
                restrictions: [
                    new models_2.AttributeFilter({
                        credentialDefinitionId: proposedAttributes[0].credentialDefinitionId,
                    }),
                ],
            });
            proofRequest.requestedAttributes.set(referent, requestedAttribute);
        }
        // Transform proposed predicates to requested predicates
        for (const proposedPredicate of preview.predicates) {
            const requestedPredicate = new models_2.ProofPredicateInfo({
                name: proposedPredicate.name,
                predicateType: proposedPredicate.predicate,
                predicateValue: proposedPredicate.threshold,
                restrictions: [
                    new models_2.AttributeFilter({
                        credentialDefinitionId: proposedPredicate.credentialDefinitionId,
                    }),
                ],
            });
            proofRequest.requestedPredicates.set((0, uuid_1.uuid)(), requestedPredicate);
        }
        return proofRequest;
    }
};
IndyProofFormatService = __decorate([
    (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig,
        indy_1.IndyHolderService,
        indy_1.IndyVerifierService,
        indy_1.IndyRevocationService,
        ledger_1.IndyLedgerService,
        DidCommMessageRepository_1.DidCommMessageRepository,
        IndyWallet_1.IndyWallet])
], IndyProofFormatService);
exports.IndyProofFormatService = IndyProofFormatService;
//# sourceMappingURL=IndyProofFormatService.js.map