"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.W3cCredentialService = void 0;
const WalletKeyPair_1 = require("../../crypto/WalletKeyPair");
const error_1 = require("../../error");
const plugins_1 = require("../../plugins");
const utils_1 = require("../../utils");
const dids_1 = require("../dids");
const key_type_1 = require("../dids/domain/key-type");
const SignatureSuiteRegistry_1 = require("./SignatureSuiteRegistry");
const W3cVcModuleConfig_1 = require("./W3cVcModuleConfig");
const deriveProof_1 = require("./deriveProof");
const jsonldUtil_1 = require("./jsonldUtil");
const jsonld_1 = __importDefault(require("./libraries/jsonld"));
const vc_1 = __importDefault(require("./libraries/vc"));
const models_1 = require("./models");
const W3cPresentation_1 = require("./models/presentation/W3cPresentation");
const W3cVerifiablePresentation_1 = require("./models/presentation/W3cVerifiablePresentation");
const repository_1 = require("./repository");
let W3cCredentialService = class W3cCredentialService {
    constructor(w3cCredentialRepository, signatureSuiteRegistry, w3cVcModuleConfig) {
        this.w3cCredentialRepository = w3cCredentialRepository;
        this.signatureSuiteRegistry = signatureSuiteRegistry;
        this.w3cVcModuleConfig = w3cVcModuleConfig;
    }
    /**
     * Signs a credential
     *
     * @param credential the credential to be signed
     * @returns the signed credential
     */
    async signCredential(agentContext, options) {
        var _a;
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        const signingKey = await this.getPublicKeyFromVerificationMethod(agentContext, options.verificationMethod);
        const suiteInfo = this.signatureSuiteRegistry.getByProofType(options.proofType);
        if (!suiteInfo.keyTypes.includes(signingKey.keyType)) {
            throw new error_1.AriesFrameworkError('The key type of the verification method does not match the suite');
        }
        const keyPair = new WalletKeyPair({
            controller: options.credential.issuerId,
            id: options.verificationMethod,
            key: signingKey,
            wallet: agentContext.wallet,
        });
        const SuiteClass = suiteInfo.suiteClass;
        const suite = new SuiteClass({
            key: keyPair,
            LDKeyClass: WalletKeyPair,
            proof: {
                verificationMethod: options.verificationMethod,
            },
            useNativeCanonize: false,
            date: (_a = options.created) !== null && _a !== void 0 ? _a : (0, jsonldUtil_1.w3cDate)(),
        });
        const result = await vc_1.default.issue({
            credential: utils_1.JsonTransformer.toJSON(options.credential),
            suite: suite,
            purpose: options.proofPurpose,
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        });
        return utils_1.JsonTransformer.fromJSON(result, models_1.W3cVerifiableCredential);
    }
    /**
     * Verifies the signature(s) of a credential
     *
     * @param credential the credential to be verified
     * @returns the verification result
     */
    async verifyCredential(agentContext, options) {
        const suites = this.getSignatureSuitesForCredential(agentContext, options.credential);
        const verifyOptions = {
            credential: utils_1.JsonTransformer.toJSON(options.credential),
            suite: suites,
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        };
        // this is a hack because vcjs throws if purpose is passed as undefined or null
        if (options.proofPurpose) {
            verifyOptions['purpose'] = options.proofPurpose;
        }
        const result = await vc_1.default.verifyCredential(verifyOptions);
        return result;
    }
    /**
     * Utility method that creates a {@link W3cPresentation} from one or more {@link W3cVerifiableCredential}s.
     *
     * **NOTE: the presentation that is returned is unsigned.**
     *
     * @param credentials One or more instances of {@link W3cVerifiableCredential}
     * @param [id] an optional unique identifier for the presentation
     * @param [holderUrl] an optional identifier identifying the entity that is generating the presentation
     * @returns An instance of {@link W3cPresentation}
     */
    async createPresentation(options) {
        if (!Array.isArray(options.credentials)) {
            options.credentials = [options.credentials];
        }
        const presentationJson = vc_1.default.createPresentation({
            verifiableCredential: options.credentials.map((credential) => utils_1.JsonTransformer.toJSON(credential)),
            id: options.id,
            holder: options.holderUrl,
        });
        return utils_1.JsonTransformer.fromJSON(presentationJson, W3cPresentation_1.W3cPresentation);
    }
    /**
     * Signs a presentation including the credentials it includes
     *
     * @param presentation the presentation to be signed
     * @returns the signed presentation
     */
    async signPresentation(agentContext, options) {
        // create keyPair
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        const suiteInfo = this.signatureSuiteRegistry.getByProofType(options.signatureType);
        if (!suiteInfo) {
            throw new error_1.AriesFrameworkError(`The requested proofType ${options.signatureType} is not supported`);
        }
        const signingKey = await this.getPublicKeyFromVerificationMethod(agentContext, options.verificationMethod);
        if (!suiteInfo.keyTypes.includes(signingKey.keyType)) {
            throw new error_1.AriesFrameworkError('The key type of the verification method does not match the suite');
        }
        const documentLoader = this.w3cVcModuleConfig.documentLoader(agentContext);
        const verificationMethodObject = (await documentLoader(options.verificationMethod)).document;
        const keyPair = new WalletKeyPair({
            controller: verificationMethodObject['controller'],
            id: options.verificationMethod,
            key: signingKey,
            wallet: agentContext.wallet,
        });
        const suite = new suiteInfo.suiteClass({
            LDKeyClass: WalletKeyPair,
            proof: {
                verificationMethod: options.verificationMethod,
            },
            date: new Date().toISOString(),
            key: keyPair,
            useNativeCanonize: false,
        });
        const result = await vc_1.default.signPresentation({
            presentation: utils_1.JsonTransformer.toJSON(options.presentation),
            suite: suite,
            challenge: options.challenge,
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        });
        return utils_1.JsonTransformer.fromJSON(result, W3cVerifiablePresentation_1.W3cVerifiablePresentation);
    }
    /**
     * Verifies a presentation including the credentials it includes
     *
     * @param presentation the presentation to be verified
     * @returns the verification result
     */
    async verifyPresentation(agentContext, options) {
        // create keyPair
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        let proofs = options.presentation.proof;
        if (!Array.isArray(proofs)) {
            proofs = [proofs];
        }
        if (options.purpose) {
            proofs = proofs.filter((proof) => proof.proofPurpose === options.purpose.term);
        }
        const presentationSuites = proofs.map((proof) => {
            const SuiteClass = this.signatureSuiteRegistry.getByProofType(proof.type).suiteClass;
            return new SuiteClass({
                LDKeyClass: WalletKeyPair,
                proof: {
                    verificationMethod: proof.verificationMethod,
                },
                date: proof.created,
                useNativeCanonize: false,
            });
        });
        const credentials = Array.isArray(options.presentation.verifiableCredential)
            ? options.presentation.verifiableCredential
            : [options.presentation.verifiableCredential];
        const credentialSuites = credentials.map((credential) => this.getSignatureSuitesForCredential(agentContext, credential));
        const allSuites = presentationSuites.concat(...credentialSuites);
        const verifyOptions = {
            presentation: utils_1.JsonTransformer.toJSON(options.presentation),
            suite: allSuites,
            challenge: options.challenge,
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        };
        // this is a hack because vcjs throws if purpose is passed as undefined or null
        if (options.purpose) {
            verifyOptions['presentationPurpose'] = options.purpose;
        }
        const result = await vc_1.default.verify(verifyOptions);
        return result;
    }
    async deriveProof(agentContext, options) {
        // TODO: make suite dynamic
        const suiteInfo = this.signatureSuiteRegistry.getByProofType('BbsBlsSignatureProof2020');
        const SuiteClass = suiteInfo.suiteClass;
        const suite = new SuiteClass();
        const proof = await (0, deriveProof_1.deriveProof)(utils_1.JsonTransformer.toJSON(options.credential), options.revealDocument, {
            suite: suite,
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        });
        return proof;
    }
    async getPublicKeyFromVerificationMethod(agentContext, verificationMethod) {
        const documentLoader = this.w3cVcModuleConfig.documentLoader(agentContext);
        const verificationMethodObject = await documentLoader(verificationMethod);
        const verificationMethodClass = utils_1.JsonTransformer.fromJSON(verificationMethodObject.document, dids_1.VerificationMethod);
        const key = (0, key_type_1.getKeyDidMappingByVerificationMethod)(verificationMethodClass);
        return key.getKeyFromVerificationMethod(verificationMethodClass);
    }
    /**
     * Writes a credential to storage
     *
     * @param record the credential to be stored
     * @returns the credential record that was written to storage
     */
    async storeCredential(agentContext, options) {
        // Get the expanded types
        const expandedTypes = (await jsonld_1.default.expand(utils_1.JsonTransformer.toJSON(options.credential), {
            documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext),
        }))[0]['@type'];
        // Create an instance of the w3cCredentialRecord
        const w3cCredentialRecord = new repository_1.W3cCredentialRecord({
            tags: { expandedTypes: (0, jsonldUtil_1.orArrayToArray)(expandedTypes) },
            credential: options.credential,
        });
        // Store the w3c credential record
        await this.w3cCredentialRepository.save(agentContext, w3cCredentialRecord);
        return w3cCredentialRecord;
    }
    async removeCredentialRecord(agentContext, id) {
        const credential = await this.w3cCredentialRepository.getById(agentContext, id);
        await this.w3cCredentialRepository.delete(agentContext, credential);
    }
    async getAllCredentialRecords(agentContext) {
        return await this.w3cCredentialRepository.getAll(agentContext);
    }
    async getCredentialRecordById(agentContext, id) {
        return await this.w3cCredentialRepository.getById(agentContext, id);
    }
    async findCredentialRecordsByQuery(agentContext, query) {
        const result = await this.w3cCredentialRepository.findByQuery(agentContext, query);
        return result.map((record) => record.credential);
    }
    getVerificationMethodTypesByProofType(proofType) {
        return this.signatureSuiteRegistry.getByProofType(proofType).verificationMethodTypes;
    }
    getKeyTypesByProofType(proofType) {
        return this.signatureSuiteRegistry.getByProofType(proofType).keyTypes;
    }
    async findCredentialRecordByQuery(agentContext, query) {
        const result = await this.w3cCredentialRepository.findSingleByQuery(agentContext, query);
        return result === null || result === void 0 ? void 0 : result.credential;
    }
    getSignatureSuitesForCredential(agentContext, credential) {
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        let proofs = credential.proof;
        if (!Array.isArray(proofs)) {
            proofs = [proofs];
        }
        return proofs.map((proof) => {
            var _a;
            const SuiteClass = (_a = this.signatureSuiteRegistry.getByProofType(proof.type)) === null || _a === void 0 ? void 0 : _a.suiteClass;
            if (SuiteClass) {
                return new SuiteClass({
                    LDKeyClass: WalletKeyPair,
                    proof: {
                        verificationMethod: proof.verificationMethod,
                    },
                    date: proof.created,
                    useNativeCanonize: false,
                });
            }
        });
    }
};
W3cCredentialService = __decorate([
    (0, plugins_1.injectable)(),
    __metadata("design:paramtypes", [repository_1.W3cCredentialRepository,
        SignatureSuiteRegistry_1.SignatureSuiteRegistry,
        W3cVcModuleConfig_1.W3cVcModuleConfig])
], W3cCredentialService);
exports.W3cCredentialService = W3cCredentialService;
//# sourceMappingURL=W3cCredentialService.js.map