"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyRevocationService = void 0;
const constants_1 = require("../../../constants");
const AriesFrameworkError_1 = require("../../../error/AriesFrameworkError");
const IndySdkError_1 = require("../../../error/IndySdkError");
const plugins_1 = require("../../../plugins");
const indyError_1 = require("../../../utils/indyError");
const ledger_1 = require("../../ledger");
const IndyUtilitiesService_1 = require("./IndyUtilitiesService");
var RequestReferentType;
(function (RequestReferentType) {
    RequestReferentType["Attribute"] = "attribute";
    RequestReferentType["Predicate"] = "predicate";
    RequestReferentType["SelfAttestedAttribute"] = "self-attested-attribute";
})(RequestReferentType || (RequestReferentType = {}));
let IndyRevocationService = class IndyRevocationService {
    constructor(indyUtilitiesService, ledgerService, agentDependencies, logger) {
        this.indy = agentDependencies.indy;
        this.indyUtilitiesService = indyUtilitiesService;
        this.logger = logger;
        this.ledgerService = ledgerService;
    }
    async createRevocationState(agentContext, proofRequest, requestedCredentials) {
        try {
            this.logger.debug(`Creating Revocation State(s) for proof request`, {
                proofRequest,
                requestedCredentials,
            });
            const revocationStates = {};
            const referentCredentials = [];
            //Retrieve information for referents and push to single array
            for (const [referent, requestedCredential] of Object.entries(requestedCredentials.requestedAttributes)) {
                referentCredentials.push({
                    referent,
                    credentialInfo: requestedCredential.credentialInfo,
                    type: RequestReferentType.Attribute,
                });
            }
            for (const [referent, requestedCredential] of Object.entries(requestedCredentials.requestedPredicates)) {
                referentCredentials.push({
                    referent,
                    credentialInfo: requestedCredential.credentialInfo,
                    type: RequestReferentType.Predicate,
                });
            }
            for (const { referent, credentialInfo, type } of referentCredentials) {
                if (!credentialInfo) {
                    throw new AriesFrameworkError_1.AriesFrameworkError(`Credential for referent '${referent} does not have credential info for revocation state creation`);
                }
                // Prefer referent-specific revocation interval over global revocation interval
                const referentRevocationInterval = type === RequestReferentType.Predicate
                    ? proofRequest.requested_predicates[referent].non_revoked
                    : proofRequest.requested_attributes[referent].non_revoked;
                const requestRevocationInterval = referentRevocationInterval !== null && referentRevocationInterval !== void 0 ? referentRevocationInterval : proofRequest.non_revoked;
                const credentialRevocationId = credentialInfo.credentialRevocationId;
                const revocationRegistryId = credentialInfo.revocationRegistryId;
                // If revocation interval is present and the credential is revocable then create revocation state
                if (requestRevocationInterval && credentialRevocationId && revocationRegistryId) {
                    this.logger.trace(`Presentation is requesting proof of non revocation for ${type} referent '${referent}', creating revocation state for credential`, {
                        requestRevocationInterval,
                        credentialRevocationId,
                        revocationRegistryId,
                    });
                    this.assertRevocationInterval(requestRevocationInterval);
                    const { revocationRegistryDefinition } = await this.ledgerService.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
                    const { revocationRegistryDelta, deltaTimestamp } = await this.ledgerService.getRevocationRegistryDelta(agentContext, revocationRegistryId, requestRevocationInterval === null || requestRevocationInterval === void 0 ? void 0 : requestRevocationInterval.to, 0);
                    const { tailsLocation, tailsHash } = revocationRegistryDefinition.value;
                    const tails = await this.indyUtilitiesService.downloadTails(tailsHash, tailsLocation);
                    const revocationState = await this.indy.createRevocationState(tails, revocationRegistryDefinition, revocationRegistryDelta, deltaTimestamp, credentialRevocationId);
                    const timestamp = revocationState.timestamp;
                    if (!revocationStates[revocationRegistryId]) {
                        revocationStates[revocationRegistryId] = {};
                    }
                    revocationStates[revocationRegistryId][timestamp] = revocationState;
                }
            }
            this.logger.debug(`Created Revocation States for Proof Request`, {
                revocationStates,
            });
            return revocationStates;
        }
        catch (error) {
            this.logger.error(`Error creating Indy Revocation State for Proof Request`, {
                error,
                proofRequest,
                requestedCredentials,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    // Get revocation status for credential (given a from-to)
    // Note from-to interval details: https://github.com/hyperledger/indy-hipe/blob/master/text/0011-cred-revocation/README.md#indy-node-revocation-registry-intervals
    async getRevocationStatus(agentContext, credentialRevocationId, revocationRegistryDefinitionId, requestRevocationInterval) {
        var _a;
        this.logger.trace(`Fetching Credential Revocation Status for Credential Revocation Id '${credentialRevocationId}' with revocation interval with to '${requestRevocationInterval.to}' & from '${requestRevocationInterval.from}'`);
        this.assertRevocationInterval(requestRevocationInterval);
        const { revocationRegistryDelta, deltaTimestamp } = await this.ledgerService.getRevocationRegistryDelta(agentContext, revocationRegistryDefinitionId, requestRevocationInterval.to, 0);
        const revoked = ((_a = revocationRegistryDelta.value.revoked) === null || _a === void 0 ? void 0 : _a.includes(parseInt(credentialRevocationId))) || false;
        this.logger.trace(`Credential with Credential Revocation Id '${credentialRevocationId}' is ${revoked ? '' : 'not '}revoked with revocation interval with to '${requestRevocationInterval.to}' & from '${requestRevocationInterval.from}'`);
        return {
            revoked,
            deltaTimestamp,
        };
    }
    // TODO: Add Test
    // Check revocation interval in accordance with https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0441-present-proof-best-practices/README.md#semantics-of-non-revocation-interval-endpoints
    assertRevocationInterval(requestRevocationInterval) {
        if (!requestRevocationInterval.to) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Presentation requests proof of non-revocation with no 'to' value specified`);
        }
        if ((requestRevocationInterval.from || requestRevocationInterval.from === 0) &&
            requestRevocationInterval.to !== requestRevocationInterval.from) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Presentation requests proof of non-revocation with an interval from: '${requestRevocationInterval.from}' that does not match the interval to: '${requestRevocationInterval.to}', as specified in Aries RFC 0441`);
        }
    }
};
IndyRevocationService = __decorate([
    (0, plugins_1.injectable)(),
    __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
    __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
    __metadata("design:paramtypes", [IndyUtilitiesService_1.IndyUtilitiesService,
        ledger_1.IndyLedgerService, Object, Object])
], IndyRevocationService);
exports.IndyRevocationService = IndyRevocationService;
//# sourceMappingURL=IndyRevocationService.js.map