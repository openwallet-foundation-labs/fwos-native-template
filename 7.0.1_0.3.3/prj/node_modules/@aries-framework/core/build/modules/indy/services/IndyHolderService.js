"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyHolderService = void 0;
const constants_1 = require("../../../constants");
const IndySdkError_1 = require("../../../error/IndySdkError");
const plugins_1 = require("../../../plugins");
const indyError_1 = require("../../../utils/indyError");
const assertIndyWallet_1 = require("../../../wallet/util/assertIndyWallet");
const IndyRevocationService_1 = require("./IndyRevocationService");
let IndyHolderService = class IndyHolderService {
    constructor(indyRevocationService, logger, agentDependencies) {
        this.indy = agentDependencies.indy;
        this.indyRevocationService = indyRevocationService;
        this.logger = logger;
    }
    /**
     * Creates an Indy Proof in response to a proof request. Will create revocation state if the proof request requests proof of non-revocation
     *
     * @param proofRequest a Indy proof request
     * @param requestedCredentials the requested credentials to use for the proof creation
     * @param schemas schemas to use in proof creation
     * @param credentialDefinitions credential definitions to use in proof creation
     * @throws {Error} if there is an error during proof generation or revocation state generation
     * @returns a promise of Indy Proof
     *
     * @todo support attribute non_revoked fields
     */
    async createProof(agentContext, { proofRequest, requestedCredentials, schemas, credentialDefinitions }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            this.logger.debug('Creating Indy Proof');
            const revocationStates = await this.indyRevocationService.createRevocationState(agentContext, proofRequest, requestedCredentials);
            const indyProof = await this.indy.proverCreateProof(agentContext.wallet.handle, proofRequest, requestedCredentials.toJSON(), agentContext.wallet.masterSecretId, schemas, credentialDefinitions, revocationStates);
            this.logger.trace('Created Indy Proof', {
                indyProof,
            });
            return indyProof;
        }
        catch (error) {
            this.logger.error(`Error creating Indy Proof`, {
                error,
                proofRequest,
                requestedCredentials,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    /**
     * Store a credential in the wallet.
     *
     * @returns The credential id
     */
    async storeCredential(agentContext, { credentialRequestMetadata, credential, credentialDefinition, credentialId, revocationRegistryDefinition, }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            return await this.indy.proverStoreCredential(agentContext.wallet.handle, credentialId !== null && credentialId !== void 0 ? credentialId : null, credentialRequestMetadata, credential, credentialDefinition, revocationRegistryDefinition !== null && revocationRegistryDefinition !== void 0 ? revocationRegistryDefinition : null);
        }
        catch (error) {
            this.logger.error(`Error storing Indy Credential '${credentialId}'`, {
                error,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    /**
     * Get a credential stored in the wallet by id.
     *
     * @param credentialId the id (referent) of the credential
     * @throws {Error} if the credential is not found
     * @returns the credential
     *
     * @todo handle record not found
     */
    async getCredential(agentContext, credentialId) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            return await this.indy.proverGetCredential(agentContext.wallet.handle, credentialId);
        }
        catch (error) {
            this.logger.error(`Error getting Indy Credential '${credentialId}'`, {
                error,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    /**
     * Create a credential request for the given credential offer.
     *
     * @returns The credential request and the credential request metadata
     */
    async createCredentialRequest(agentContext, { holderDid, credentialOffer, credentialDefinition }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            return await this.indy.proverCreateCredentialReq(agentContext.wallet.handle, holderDid, credentialOffer, credentialDefinition, agentContext.wallet.masterSecretId);
        }
        catch (error) {
            this.logger.error(`Error creating Indy Credential Request`, {
                error,
                credentialOffer,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    /**
     * Retrieve the credentials that are available for an attribute referent in the proof request.
     *
     * @param proofRequest The proof request to retrieve the credentials for
     * @param attributeReferent An attribute referent from the proof request to retrieve the credentials for
     * @param start Starting index
     * @param limit Maximum number of records to return
     *
     * @returns List of credentials that are available for building a proof for the given proof request
     *
     */
    async getCredentialsForProofRequest(agentContext, { proofRequest, attributeReferent, start = 0, limit = 256, extraQuery }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            // Open indy credential search
            const searchHandle = await this.indy.proverSearchCredentialsForProofReq(agentContext.wallet.handle, proofRequest, extraQuery !== null && extraQuery !== void 0 ? extraQuery : null);
            try {
                // Make sure database cursors start at 'start' (bit ugly, but no way around in indy)
                if (start > 0) {
                    await this.fetchCredentialsForReferent(searchHandle, attributeReferent, start);
                }
                // Fetch the credentials
                const credentials = await this.fetchCredentialsForReferent(searchHandle, attributeReferent, limit);
                // TODO: sort the credentials (irrevocable first)
                return credentials;
            }
            finally {
                // Always close search
                await this.indy.proverCloseCredentialsSearchForProofReq(searchHandle);
            }
        }
        catch (error) {
            if ((0, indyError_1.isIndyError)(error)) {
                throw new IndySdkError_1.IndySdkError(error);
            }
            throw error;
        }
    }
    /**
     * Delete a credential stored in the wallet by id.
     *
     * @param credentialId the id (referent) of the credential
     *
     */
    async deleteCredential(agentContext, credentialId) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
            return await this.indy.proverDeleteCredential(agentContext.wallet.handle, credentialId);
        }
        catch (error) {
            this.logger.error(`Error deleting Indy Credential from Wallet`, {
                error,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
    async fetchCredentialsForReferent(searchHandle, referent, limit) {
        try {
            let credentials = [];
            // Allow max of 256 per fetch operation
            const chunk = limit ? Math.min(256, limit) : 256;
            // Loop while limit not reached (or no limit specified)
            while (!limit || credentials.length < limit) {
                // Retrieve credentials
                const credentialsJson = await this.indy.proverFetchCredentialsForProofReq(searchHandle, referent, chunk);
                credentials = [...credentials, ...credentialsJson];
                // If the number of credentials returned is less than chunk
                // It means we reached the end of the iterator (no more credentials)
                if (credentialsJson.length < chunk) {
                    return credentials;
                }
            }
            return credentials;
        }
        catch (error) {
            this.logger.error(`Error Fetching Indy Credentials For Referent`, {
                error,
            });
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
    }
};
IndyHolderService = __decorate([
    (0, plugins_1.injectable)(),
    __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
    __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
    __metadata("design:paramtypes", [IndyRevocationService_1.IndyRevocationService, Object, Object])
], IndyHolderService);
exports.IndyHolderService = IndyHolderService;
//# sourceMappingURL=IndyHolderService.js.map