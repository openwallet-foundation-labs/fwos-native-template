"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyCredentialFormatService = void 0;
const crypto_1 = require("../../../../crypto");
const Attachment_1 = require("../../../../decorators/attachment/Attachment");
const error_1 = require("../../../../error");
const JsonEncoder_1 = require("../../../../utils/JsonEncoder");
const JsonTransformer_1 = require("../../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const TypedArrayEncoder_1 = require("../../../../utils/TypedArrayEncoder");
const did_1 = require("../../../../utils/did");
const uuid_1 = require("../../../../utils/uuid");
const connections_1 = require("../../../connections");
const dids_1 = require("../../../dids");
const IndyHolderService_1 = require("../../../indy/services/IndyHolderService");
const IndyIssuerService_1 = require("../../../indy/services/IndyIssuerService");
const ledger_1 = require("../../../ledger");
const errors_1 = require("../../errors");
const CredentialFormatSpec_1 = require("../../models/CredentialFormatSpec");
const CredentialPreviewAttribute_1 = require("../../models/CredentialPreviewAttribute");
const CredentialMetadataTypes_1 = require("../../repository/CredentialMetadataTypes");
const IndyCredentialUtils_1 = require("./IndyCredentialUtils");
const IndyCredPropose_1 = require("./models/IndyCredPropose");
const INDY_CRED_ABSTRACT = 'hlindy/cred-abstract@v2.0';
const INDY_CRED_REQUEST = 'hlindy/cred-req@v2.0';
const INDY_CRED_FILTER = 'hlindy/cred-filter@v2.0';
const INDY_CRED = 'hlindy/cred@v2.0';
class IndyCredentialFormatService {
    constructor() {
        this.formatKey = 'indy';
        this.credentialRecordType = 'indy';
    }
    /**
     * Create a {@link AttachmentFormats} object dependent on the message type.
     *
     * @param options The object containing all the options for the proposed credential
     * @returns object containing associated attachment, format and optionally the credential preview
     *
     */
    async createProposal(agentContext, { credentialFormats, credentialRecord }) {
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            format: INDY_CRED_FILTER,
        });
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
            throw new error_1.AriesFrameworkError('Missing indy payload in createProposal');
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { attributes, linkedAttachments } = indyFormat, indyCredentialProposal = __rest(indyFormat, ["attributes", "linkedAttachments"]);
        const proposal = new IndyCredPropose_1.IndyCredPropose(indyCredentialProposal);
        try {
            MessageValidator_1.MessageValidator.validateSync(proposal);
        }
        catch (error) {
            throw new error_1.AriesFrameworkError(`Invalid proposal supplied: ${indyCredentialProposal} in Indy Format Service`);
        }
        const proposalJson = JsonTransformer_1.JsonTransformer.toJSON(proposal);
        const attachment = this.getFormatData(proposalJson, format.attachId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(indyFormat.attributes, indyFormat.linkedAttachments);
        // Set the metadata
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: proposal.schemaId,
            credentialDefinitionId: proposal.credentialDefinitionId,
        });
        return { format, attachment, previewAttributes };
    }
    async processProposal(agentContext, { attachment }) {
        const proposalJson = attachment.getDataAsJson();
        // fromJSON also validates
        JsonTransformer_1.JsonTransformer.fromJSON(proposalJson, IndyCredPropose_1.IndyCredPropose);
    }
    async acceptProposal(agentContext, { attachId, credentialFormats, credentialRecord, proposalAttachment, }) {
        var _a, _b;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(proposalAttachment.getDataAsJson(), IndyCredPropose_1.IndyCredPropose);
        const credentialDefinitionId = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.credentialDefinitionId) !== null && _a !== void 0 ? _a : credentialProposal.credentialDefinitionId;
        const attributes = (_b = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.attributes) !== null && _b !== void 0 ? _b : credentialRecord.credentialAttributes;
        if (!credentialDefinitionId) {
            throw new error_1.AriesFrameworkError('No credentialDefinitionId in proposal or provided as input to accept proposal method.');
        }
        if (!attributes) {
            throw new error_1.AriesFrameworkError('No attributes in proposal or provided as input to accept proposal method.');
        }
        const { format, attachment, previewAttributes } = await this.createIndyOffer(agentContext, {
            credentialRecord,
            attachId,
            attributes,
            credentialDefinitionId: credentialDefinitionId,
            linkedAttachments: indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.linkedAttachments,
        });
        return { format, attachment, previewAttributes };
    }
    /**
     * Create a credential attachment format for a credential request.
     *
     * @param options The object containing all the options for the credential offer
     * @returns object containing associated attachment, formats and offersAttach elements
     *
     */
    async createOffer(agentContext, { credentialFormats, credentialRecord, attachId }) {
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
            throw new error_1.AriesFrameworkError('Missing indy credentialFormat data');
        }
        const { format, attachment, previewAttributes } = await this.createIndyOffer(agentContext, {
            credentialRecord,
            attachId,
            attributes: indyFormat.attributes,
            credentialDefinitionId: indyFormat.credentialDefinitionId,
            linkedAttachments: indyFormat.linkedAttachments,
        });
        return { format, attachment, previewAttributes };
    }
    async processOffer(agentContext, { attachment, credentialRecord }) {
        agentContext.config.logger.debug(`Processing indy credential offer for credential record ${credentialRecord.id}`);
        const credOffer = attachment.getDataAsJson();
        if (!credOffer.schema_id || !credOffer.cred_def_id) {
            throw new errors_1.CredentialProblemReportError('Invalid credential offer', {
                problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned,
            });
        }
    }
    async acceptOffer(agentContext, { credentialFormats, credentialRecord, attachId, offerAttachment }) {
        var _a;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        const holderDid = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.holderDid) !== null && _a !== void 0 ? _a : (await this.getIndyHolderDid(agentContext, credentialRecord));
        const credentialOffer = offerAttachment.getDataAsJson();
        const credentialDefinition = await indyLedgerService.getCredentialDefinition(agentContext, credentialOffer.cred_def_id);
        const [credentialRequest, credentialRequestMetadata] = await indyHolderService.createCredentialRequest(agentContext, {
            holderDid,
            credentialOffer,
            credentialDefinition,
        });
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, credentialRequestMetadata);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            credentialDefinitionId: credentialOffer.cred_def_id,
            schemaId: credentialOffer.schema_id,
        });
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId,
            format: INDY_CRED_REQUEST,
        });
        const attachment = this.getFormatData(credentialRequest, format.attachId);
        return { format, attachment };
    }
    /**
     * Starting from a request is not supported for indy credentials, this method only throws an error.
     */
    async createRequest() {
        throw new error_1.AriesFrameworkError('Starting from a request is not supported for indy credentials');
    }
    /**
     * We don't have any models to validate an indy request object, for now this method does nothing
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async processRequest(agentContext, options) {
        // not needed for Indy
    }
    async acceptRequest(agentContext, { credentialRecord, attachId, offerAttachment, requestAttachment }) {
        // Assert credential attributes
        const credentialAttributes = credentialRecord.credentialAttributes;
        if (!credentialAttributes) {
            throw new errors_1.CredentialProblemReportError(`Missing required credential attribute values on credential record with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyIssuerService = agentContext.dependencyManager.resolve(IndyIssuerService_1.IndyIssuerService);
        const credentialOffer = offerAttachment === null || offerAttachment === void 0 ? void 0 : offerAttachment.getDataAsJson();
        const credentialRequest = requestAttachment.getDataAsJson();
        if (!credentialOffer || !credentialRequest) {
            throw new error_1.AriesFrameworkError('Missing indy credential offer or credential request in createCredential');
        }
        const [credential, credentialRevocationId] = await indyIssuerService.createCredential(agentContext, {
            credentialOffer,
            credentialRequest,
            credentialValues: IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialAttributes),
        });
        if (credential.rev_reg_id) {
            credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                indyCredentialRevocationId: credentialRevocationId,
                indyRevocationRegistryId: credential.rev_reg_id,
            });
        }
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId,
            format: INDY_CRED,
        });
        const attachment = this.getFormatData(credential, format.attachId);
        return { format, attachment };
    }
    /**
     * Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet
     * @param options the issue credential message wrapped inside this object
     * @param credentialRecord the credential exchange record for this credential
     */
    async processCredential(agentContext, { credentialRecord, attachment }) {
        const credentialRequestMetadata = credentialRecord.metadata.get(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest);
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        if (!credentialRequestMetadata) {
            throw new errors_1.CredentialProblemReportError(`Missing required request metadata for credential with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyCredential = attachment.getDataAsJson();
        const credentialDefinition = await indyLedgerService.getCredentialDefinition(agentContext, indyCredential.cred_def_id);
        const revocationRegistry = indyCredential.rev_reg_id
            ? await indyLedgerService.getRevocationRegistryDefinition(agentContext, indyCredential.rev_reg_id)
            : null;
        if (!credentialRecord.credentialAttributes) {
            throw new error_1.AriesFrameworkError('Missing credential attributes on credential record. Unable to check credential attributes');
        }
        // assert the credential values match the offer values
        const recordCredentialValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        IndyCredentialUtils_1.IndyCredentialUtils.assertValuesMatch(indyCredential.values, recordCredentialValues);
        const credentialId = await indyHolderService.storeCredential(agentContext, {
            credentialId: (0, uuid_1.uuid)(),
            credentialRequestMetadata,
            credential: indyCredential,
            credentialDefinition,
            revocationRegistryDefinition: revocationRegistry === null || revocationRegistry === void 0 ? void 0 : revocationRegistry.revocationRegistryDefinition,
        });
        // If the credential is revocable, store the revocation identifiers in the credential record
        if (indyCredential.rev_reg_id) {
            const credential = await indyHolderService.getCredential(agentContext, credentialId);
            credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                indyCredentialRevocationId: credential.cred_rev_id,
                indyRevocationRegistryId: indyCredential.rev_reg_id,
            });
        }
        credentialRecord.credentials.push({
            credentialRecordType: this.credentialRecordType,
            credentialRecordId: credentialId,
        });
    }
    supportsFormat(format) {
        const supportedFormats = [INDY_CRED_ABSTRACT, INDY_CRED_REQUEST, INDY_CRED_FILTER, INDY_CRED];
        return supportedFormats.includes(format);
    }
    /**
     * Gets the attachment object for a given attachId. We need to get out the correct attachId for
     * indy and then find the corresponding attachment (if there is one)
     * @param formats the formats object containing the attachId
     * @param messageAttachments the attachments containing the payload
     * @returns The Attachment if found or undefined
     *
     */
    getAttachment(formats, messageAttachments) {
        const supportedAttachmentIds = formats.filter((f) => this.supportsFormat(f.format)).map((f) => f.attachId);
        const supportedAttachments = messageAttachments.filter((attachment) => supportedAttachmentIds.includes(attachment.id));
        return supportedAttachments[0];
    }
    async deleteCredentialById(agentContext, credentialRecordId) {
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        await indyHolderService.deleteCredential(agentContext, credentialRecordId);
    }
    shouldAutoRespondToProposal(agentContext, { offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        // We want to make sure the credential definition matches.
        // TODO: If no credential definition is present on the proposal, we could check whether the other fields
        // of the proposal match with the credential definition id.
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
    }
    shouldAutoRespondToOffer(agentContext, { offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        // We want to make sure the credential definition matches.
        // TODO: If no credential definition is present on the proposal, we could check whether the other fields
        // of the proposal match with the credential definition id.
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
    }
    shouldAutoRespondToRequest(agentContext, { offerAttachment, requestAttachment }) {
        const credentialOfferJson = offerAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        return credentialOfferJson.cred_def_id == credentialRequestJson.cred_def_id;
    }
    shouldAutoRespondToCredential(agentContext, { credentialRecord, requestAttachment, credentialAttachment }) {
        const credentialJson = credentialAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        // make sure the credential definition matches
        if (credentialJson.cred_def_id !== credentialRequestJson.cred_def_id)
            return false;
        // If we don't have any attributes stored we can't compare so always return false.
        if (!credentialRecord.credentialAttributes)
            return false;
        const attributeValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        // check whether the values match the values in the record
        return IndyCredentialUtils_1.IndyCredentialUtils.checkValuesMatch(attributeValues, credentialJson.values);
    }
    async createIndyOffer(agentContext, { credentialRecord, attachId, credentialDefinitionId, attributes, linkedAttachments, }) {
        const indyIssuerService = agentContext.dependencyManager.resolve(IndyIssuerService_1.IndyIssuerService);
        // if the proposal has an attachment Id use that, otherwise the generated id of the formats object
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId: attachId,
            format: INDY_CRED_ABSTRACT,
        });
        const offer = await indyIssuerService.createCredentialOffer(agentContext, credentialDefinitionId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(attributes, linkedAttachments);
        if (!previewAttributes) {
            throw new error_1.AriesFrameworkError('Missing required preview attributes for indy offer');
        }
        await this.assertPreviewAttributesMatchSchemaAttributes(agentContext, offer, previewAttributes);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: offer.schema_id,
            credentialDefinitionId: offer.cred_def_id,
        });
        const attachment = this.getFormatData(offer, format.attachId);
        return { format, attachment, previewAttributes };
    }
    async assertPreviewAttributesMatchSchemaAttributes(agentContext, offer, attributes) {
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const schema = await indyLedgerService.getSchema(agentContext, offer.schema_id);
        IndyCredentialUtils_1.IndyCredentialUtils.checkAttributesMatch(schema, attributes);
    }
    async getIndyHolderDid(agentContext, credentialRecord) {
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        const didResolver = agentContext.dependencyManager.resolve(dids_1.DidResolverService);
        // If we have a connection id we try to extract the did from the connection did document.
        if (credentialRecord.connectionId) {
            const connection = await connectionService.getById(agentContext, credentialRecord.connectionId);
            if (!connection.did) {
                throw new error_1.AriesFrameworkError(`Connection record ${connection.id} has no 'did'`);
            }
            const resolved = await didResolver.resolve(agentContext, connection.did);
            if (resolved.didDocument) {
                const verificationMethod = await (0, dids_1.findVerificationMethodByKeyType)('Ed25519VerificationKey2018', resolved.didDocument);
                if (verificationMethod) {
                    return (0, did_1.getIndyDidFromVerificationMethod)(verificationMethod);
                }
            }
        }
        // If it wasn't successful to extract the did from the connection, we'll create a new key (e.g. if using connection-less)
        // FIXME: we already create a did for the exchange when using connection-less, but this is on a higher level. We should look at
        // a way to reuse this key, but for now this is easier.
        const key = await agentContext.wallet.createKey({ keyType: crypto_1.KeyType.Ed25519 });
        const did = TypedArrayEncoder_1.TypedArrayEncoder.toBase58(key.publicKey.slice(0, 16));
        return did;
    }
    /**
     * Get linked attachments for indy format from a proposal message. This allows attachments
     * to be copied across to old style credential records
     *
     * @param options ProposeCredentialOptions object containing (optionally) the linked attachments
     * @return array of linked attachments or undefined if none present
     */
    getCredentialLinkedAttachments(attributes, linkedAttachments) {
        var _a;
        if (!linkedAttachments && !attributes) {
            return {};
        }
        let previewAttributes = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.map((attribute) => new CredentialPreviewAttribute_1.CredentialPreviewAttribute(attribute))) !== null && _a !== void 0 ? _a : [];
        let attachments;
        if (linkedAttachments) {
            // there are linked attachments so transform into the attribute field of the CredentialPreview object for
            // this proposal
            previewAttributes = IndyCredentialUtils_1.IndyCredentialUtils.createAndLinkAttachmentsToPreview(linkedAttachments, previewAttributes);
            attachments = linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment);
        }
        return { attachments, previewAttributes };
    }
    /**
     * Returns an object of type {@link Attachment} for use in credential exchange messages.
     * It looks up the correct format identifier and encodes the data as a base64 attachment.
     *
     * @param data The data to include in the attach object
     * @param id the attach id from the formats component of the message
     */
    getFormatData(data, id) {
        const attachment = new Attachment_1.Attachment({
            id,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(data),
            }),
        });
        return attachment;
    }
}
exports.IndyCredentialFormatService = IndyCredentialFormatService;
//# sourceMappingURL=IndyCredentialFormatService.js.map